#### 函数

所谓函数，就是解决一类问题的代码的有序组合，是一个功能模块。编程语言中的函数是组合在一起来执行操作语句的集合。

函数就是给能够解决问题的多行代码取了一个名字的功能块，封装起来了，方便我们多次使用。

###### 函数的作用

​	1、重复执行的代码块 命名，方便重复使用
		2、方便自上而下分解问题
		3、方便维护代码

###### 内置函数

系统中提供的函数

abs()，int()，float()，bool()，str()，max(arg1,arg2,arg3......) ，min(arg1,arg2,arg3......)

###### 定义函数

定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数 的 返 回 值 用 return 语 句 返 回 。

格式
		def method_name(args…):
			// method body;
			//return 返回值..

说明:
		def 声明一个函数；
	函数名：必须使用合法的标识符，见名知意，最好不要跟Python 内置函数重名；

形参列表:参数可以有多个，多个参数间以逗号隔；
	返回值：如果有返回就是用 return 返回



arguments
		先简单了解一下 形参，如果函数在定义的时候，仅作为一个模板，或者不能独立完成功能，

需要外部的数据参与运算时，函数定义时需要根据需要加入形参，个数随需要而定。



return
		在定义函数时，如果需要提前中断、结束函数或返回数据的调用，可以使用 return

函数存在 return 返回值，函数的调用处就可以接收这个数据。



pass
		此处 pass 与之前 if 和 while 中的作用一样，“占坑”后续再添加代码，也就是定义一个

什么事也不做的空函数。



###### 调用

函数必须先定义后调用，定义在前，调用在后,定义一次，使用多次。

调用 格式
		接收变量 = 函数名(实参值列表…)
		在调用时:
		1、如果有位置参数，必须给定实际值,这个值为 实参;
		2、如果有返回值，可以接收变量；没有返回值，如果接收则为 None;

调用顺序
		确保定义在前，调用在后，一次定义、多次调用即可，即
	使多个函数定义后，调用时根据调用顺序，而不是定义顺序，从上往下执行。

执行顺序
		函数必须先定义后调用，在调用时控制权由函数调用处转移到函数中，函数遇

到 return 或正常结束时，将调用权交还给调用处。

递归
		在函数自己调用其自己的函数称之为递归函数。

​	递归结构包括两个部分：
		递归头:何时不调用自身函数。如果没有尽头，将陷入死循环；
		递归体:何时需要调用自身函数

###### 返回值

函数可以无返回值，也可以为一个返回值，同时也可以为多个返回值，多个返回值其实是 元组

None

​	如果函数没有 return 则函数的返回值为 NoneType 的None

NoneType 类型的 None 对象有以下特点：
		None 有自己的数据类型 NoneType;
		它不支持任何运算也没有任何内建方法;
		None 和任何其他的数据类型比较永远返回 False;
		你可以将 None 复制给任何变量，但是你不能创建其他NoneType 对象。

一致性
		在编写函数时，如果有多种情况的返回值，尽可能确保所有情况都存在返回值，而且返回值的

类型尽量保证相同，否则接收时就会出现莫名其妙的 BUG。

###### 形参

python 中的函数形参灵活多变，简化调用代码，分为位置参数、默认参数、可变参数、关键字参数和强制关键字参数。

位置参数
		也称之为必选参数，之前我们一直使用的就是必选参数。
		位置参数是必须要传递的，个数必选匹配，如果你没有传递的话就会报错。

默认参数 Default Arguments
		现实中办理信用卡，都有默认密码，会员可以根据自身修改，同理形参也可以使用默认参数，根

据需要传递即可。

**默认参数在函数调用时使用默认值时的第一次开辟空间，后面如果再次使用默认值，不会再次开辟空间，因此如果默认参数是可变类型的数据，使用不当会影响后续函数的调用，所以建议，默认参数为不可变类型或者如果可变类型，参数设置为 None。**

可变参数 Arbitr r ary Argument
		一个函数可以用任意数量的参数来调用。这些参数将被包在一个元组中。在变量数量的参数之前，可能会出现零个或更多的正常参数。

关键字参数 Keyword Arguments
		在程序比较繁琐的时候，参数顺序是很难能记住的，为了让程序简单不出错，会为参数起一个名字，这就是关键字参数的作用。关键字参数使用 key-value 的形式进行传递

强制 关键字参数 Keyword- - Only Arguments
		在调用函数时，强制使用关键字传递参数，在参数中间加入 * ,或者中间存在可变参数*args，没有默认值，必须传递参数



fun.\__name__# 名称：返回 函数名

fun.\__doc__# 描述：返回 函数描述

#### 作用域

###### 概念

在 Python 程序中创建、改变、查找变量名时，都是在一个保存变量名的空间中进行，我们称之为命名空间，也被称之为作用域。python 的作用域是静态的，在源代码中变量名被赋值的位置决定了该变量能被访问的范围。即 Python 变量的作用域由变量所在源代码中的位置决定。
在使用变量时，会有下面四个过程:
	声明变量：让编辑器知道有这一个变量的存在；
	定义变量：为不同数据类型的变量分配内存空间；
	初始化：赋值，填充分配好的内存空间；
	引用：通过引用对象(变量名)来调用内存对象(内存数据)。
在 Python 中并不是所有的语句块中都会产生作用域。只有当变量在 Module(模块)、Class(类)、def(函数)中定义的时候，才会有作用域的概念，注意:在 if-elif-else、for-else、while、try-except\try-finally 等关键字的语句块中并不会产成作用域。

在作用域中定义的变量，一般只在作用域中有效。

###### LEGB

在函数中定义的变量称为局部变量，在程序命名空间中定义的变量称为全局变量。

locals 是函数内的名字空间，包括局部变量和形参
	enclosing 外部嵌套函数的名字空间（闭包中常见,函数嵌套函数）
	globals 全局变量，函数定义所在模块的名字空间
	builtins 内置模块的名字空间 如 time os random 等
	而查找的优先顺序即 就近原则从左到右以此是: L -> E ->G -> B 找到立即停止，如果没有找到，则会出发 NameError错误。
	使用一个变量时并不严格要求需要预先声明它，但是在真正使用它之前，它必须被绑定到某个内存对象(被定义、赋值)；这种变量名的绑定将在当前作用域中引入新的变量，同时屏蔽外层作用域中的同名变量。

###### 显示提升

global
		global 的作用是将局部变量变成全局变量，提升变量的作用域。

```
box = 'global'
def change_up():
	global box
	box = 'change'
	print("变量为:",box)
print("全局变量为:",box)
change_up()
print("全局局变量为:",box)
```

​	注意：

​		1、必须在函数赋值和使用前使用

​		2、不能在赋值的同时使用

​		3、值在函数调用后才存在

nonlocal
		在函数内部嵌套函数时，即修改闭包变量（外函数绑定给内函数的局部变量），提升变量的作用域

```
In [1]: def outter():
   ...:     scope = "putter"
   ...:     def inner():
   ...:         nonlocal scope # 提升作用域
   ...:         scope="inner"
   ...:         print(scope)
   ...:     inner()
   ...:     print(scope)
   ...:     return inner
   ...: outter()
   ...:
   ...:
inner
inner
Out[1]: <function __main__.outter.<locals>.inner()>
```

###### 引用传递

 数据的类型属于对象，变量是没有类型的，所有的变量都可以理解是内存中一个对象的“引用”。

##### 高阶函数

###### map映射

map(f, iterator), 第一个是函数本身 ， 第二个是iterator。遍历序列，对序列中每个元素进行操作，最终获取新的序列。

对容器的每个元素二次处理

```
In [3]: def square (x):
   ...:     return x * x
   ...: r = map(square, [1, 2, 3, 4, 5, 6, 7])
   ...: print(list(r))
   ...:
   ...:
[1, 4, 9, 16, 25, 36, 49]


In [5]: r = map(str, [1, 2, 3, 4, 5, 6, 7]
In [6]: print(list(r))
['1', '2', '3', '4', '5', '6', '7']
```

###### reduce规约

reduce() 函数会对参数序列中元素进行累积。
	先对列表中的第1、2个元素操作，然后再把1、2元素的返回值和第三个元素进行操作

求列表的元素总和

```
In [7]: from functools import reduce
   ...: def plus(x, y):
   ...:     return x + y
   ...: r = reduce(plus, [1, 2, 3, 4])
   ...: print(type(r), r)
   ...:
   ...:
<class 'int'> 10
```

拼接列表元素

```
In [11]: from functools import reduce
    ...: def paste_num(x, y):
    ...:     print('x',x,"y",y)
    ...:     return x * 10 + y
    ...: r = reduce(paste_num, [1, 2, 3, 4, 6])
    ...: print(r)
    ...:
    ...:
x 1 y 2
x 12 y 3
x 123 y 4
x 1234 y 6
12346
```

###### filter过滤

对于序列中的元素进行筛选，最终获取符合条件的序列

和map()类似，filter()也接收一个函数和一个序列。filter 把函数运用到列表里面的每一个元素，然后根据返回True 还是 False 来决定是否保留元素.

求列表中大于 20 的数字

```
In [13]: def compare(x):
    ...:     return x > 20
    ...: r = filter(compare, [1,2,3,4,5,8,20,30])
    ...: list(r)
    ...:
    ...:
Out[13]: [30]
```

把字符串列表中的空字符串删除

```
In [14]: def remove(x):
    ...:     if len(x.strip()) != 0: #去除前后空格
    ...:         return x
    ...: list(filter(remove, ['A', '', '', 'B', 'C']))
    ...:
    ...:
Out[14]: ['A', 'B', 'C']
```

###### 返回函数

既然函数名也是引用，因此可以在函数内返回函数

```
In [15]: def demo():
    ...:     def haha():
    ...:         print("函数作为返回值返回")
    ...:     return haha
    ...: x = demo()
    ...: x()
    ...: demo()()
    ...:
    ...:
函数作为返回值返回
函数作为返回值返回
```

###### lambda匿名函数

因为函数也是对象，也具有引用的传递，所以可以将函数引用传递给函数

==适用场景:逻辑简单、使用次数少==

```
In [1]: def myabs(n):
   ...:     return n if n > 0 else -n
   ...: def sum_abs(a, b, m):
   ...:     return m(a) + m(b)
   ...: abs_ref = myabs # 函数可以传递
   ...: box = sum_abs(1, 2, abs_ref) #传递函数以便使用
   ...: print(box)
   ...:
   ...:
3
```

Lambda 表达式”是一个匿名函数，可以包含表达式和语句。只能有一个表达式，不用写 return，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：

```
In [2]: def sum_abs(a, b, m):
   ...:     return m(a) + m(b)
   ...: box = sum_abs(1, 2, lambda n: n if n > 0 else -n) # 传递函数以便使用
   ...: print(box)
   ...:
   ...:
3
```

###### 函数生成器

遇到数据很大时，我们可以采用生成器节约空间，之前接触过列表生成器，现在使用函数的 yield 来制作函数生成器，generator 函数本意是 iterator 生成器，函数运行到 yield 时退出，并保留上下文，在下次进入时可以继续运行，现在这个特性作为协程使用将异部流程改造成同步。

```
In [4]: def print_num():
   ...:     print('step 1')
   ...:     yield 1
   ...:     print('step 2')
   ...:     yield 2
   ...:     print('step 3')
   ...:     yield 3
   ...: p = print_num()
   ...: print(next(p))
   ...: r = next(p)
   ...: print(r,type(r))
   ...: next(p)
   ...: next(p)
   ...:
   ...:
step 1
1
step 2
2 <class 'int'>
step 3
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
<ipython-input-4-3be58fb67eae> in <module>()
     11 print(r,type(r))
     12 next(p)
---> 13 next(p)

StopIteration:
```

可见 print_num 不是普通函数，而是生成器了，在执行过程中，遇到 yield 就中断，下次又继续执行。执行 3 次 yield后，已经没有 yield 可以执行了，所以，第 4 次调用 next(p)就报错。

```
In [5]: def print_num():
   ...:     print('step 1')
   ...:     yield 1
   ...:     print('step 2')
   ...:     yield 2
   ...:     print('step 3')
   ...:     yield 3
   ...: p = print_num()
   ...: # 使用 for 来遍历
   ...: for r in p :
   ...:     print(r)
   ...:
step 1
1
step 2
2
step 3
3
```

###### 偏函数

偏函数就是将函数的某些参数固定，在返回一个新的函数，简化我们去调用。

1 、构建
		1)、给偏函数取名 functools.partial
		2)、给出固定参数
	2 、实例: 翻译

```
In [1]: def translate(content, charset):
   ...:     if charset == 0:
   ...:         # 转化 16 进制
   ...:         return content.encode(encoding="utf-8")
   ...:     elif charset == 1:
   ...:         # 转化 unicode
   ...:         return content.encode(encoding="unicode_escape")
   ...:     else:
   ...:         return content
   ...: print(translate("中国", 0))
   ...: print(translate("中国", 1))
   ...:
   ...:
b'\xe4\xb8\xad\xe5\x9b\xbd'
b'\\u4e2d\\u56fd'
```

使用偏函数：

```
In [2]: import functools
   ...: trans_utf8 = functools.partial(translate,charset=0)
   ...: trans_unicode = functools.partial(translate,charset=1)
   ...: print(trans_utf8("中国"))
   ...: print(trans_unicode("中国"))
   ...:
   ...:
b'\xe4\xb8\xad\xe5\x9b\xbd'
b'\\u4e2d\\u56fd'
```

###### 内函数

函数中定义函数，外部的称之为外函数，内部的称之为内函数

```
In [3]: def f():
   ...:     print('1-----')
   ...:     def g():
   ...:         print('2----')
   ...:         print('这时 g 函数')
   ...:     print('3----')
   ...: f()
   ...:
   ...:
1-----
3----

In [5]: def f():
   ...:     print('1-----')
   ...:     def g():
   ...:         print('2----')
   ...:         print('这时 g 函数')
   ...:     print('3----')
   ...:     return g # 返回一个函数
   ...: r = f()
   ...: type(r)
   ...: r
   ...: r()
   ...:
   ...:
1-----
3----
2----
这时 g 函数
```

###### 闭包

1) 、理解

闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。

简单来说:闭包就是定义在函数里面的函数，要能记住外部函数的变量，并访问。
	内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。

闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来，外部不能访问里面的变量。

2) 、作用
		能够访问外部函数变量
		能将外部函数的变量保存在内存中而不会被垃圾回收
		实现代码的公用
	一般情况下，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是 闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。

```
In [10]: a = 1
    ...: def outter():
    ...:     a = 2
    ...:     def inner():
    ...:         print(a)
    ...:     return inner
    ...: test = outter()
    ...: test()
    ...:
    ...:
2
```



实例：

```
In [12]: # 先装水
    ...: def hold_water(water):
    ...:     bucket = {"water": water}
    ...:     # 浇花
    ...:     def water(flower):
    ...:         if bucket["water"] > 0:
    ...:             bucket["water"] = bucket["water"] - 50
    ...:             print("给“%s”浇水%dml" % (flower, 50))
    ...:         else:
    ...:             print("请装水。。")
    ...:     return water
    ...: water = hold_water(100)
    ...: water("兰花")
    ...: water("菊花")
    ...: water("梅花")
    ...:
    ...:
给“兰花”浇水50ml
给“菊花”浇水50ml
请装水。。
```

```
In [13]: def counter(num=0):
    ...:     def step():
    ...:         nonlocal num
    ...:         num +=1
    ...:         print(num)
    ...:     return step
    ...: s = counter()
    ...: s()
    ...: s()
    ...: c =counter(3) # 结果互不影响
    ...: c()
    ...: c()
    ...: c()
    ...:
    ...:
1
2
4
5
6
```

```
In [14]: def add_plus(a,b):
    ...:     return a+b
    ...: # 使用闭包拆分函数参数
    ...: def add(x):
    ...:     def plus(y):
    ...:         return y + x
    ...:     return plus
    ...: r = add(2)
    ...: print(r(4))
    ...: print(r(8))
    ...:
    ...:
6
10
```

###### 装饰函数

装饰器是一种设计模式，它的作用就是在不改变原来的功能上添加新的功能。优点就是动态扩展已有的功能，比如统计函数的执行时间；参数验证；权限认证等。装饰器一般有以下角色：

a)、Component 抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。

b)、ConcreteComponent 具体构件角色（真实对象）

c)、Decorator 装饰角色：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。

d)、ConcreteDecorator 具体装饰角色：负责给构件对象增加新的责任。



1、简单的装饰器

```
In [3]: import random
   ...: def meet_mayun():
   ...:     print("你好，马云给你 500W。。")
   ...: # 装饰器函数
   ...: def decorator(func):
   ...:     # 包装
   ...:     def wrapper():
   ...:         print("查看一下马云的日程。。")
   ...:         if random.randint(0, 1):
   ...:             func()
   ...:         else:
   ...:             print("档期已满，下次再约。。")
   ...:     return wrapper
   ...: # 这是以前调用
   ...: meet_mayun()
   ...: # 使用装饰器
   ...: wrapper = decorator(meet_mayun)
   ...: wrapper()
   ...:
   ...:
你好，马云给你 500W。。
查看一下马云的日程。。
档期已满，下次再约。。
```

在这个例子中：

Component 抽象构件角色：就是传入 decorator()函数的函数；ConcreteComponent 具 体 构 件 角 色 （ 真 实 对 象 ）：meet_mayun()；

Decorator 装饰角色：decorator()；
	ConcreteDecorator 具体装饰角色：wrapper()函数。



2、修饰符

```
In [5]: # 真实函数
   ...: @decorator # 语法糖
   ...: def meet_mayun():
   ...:     print("你好，马云给你 500W。。")
   ...: # 调用
   ...: meet_mayun()
   ...:
   ...:
查看一下马云的日程。。
你好，马云给你 500W。。

```

