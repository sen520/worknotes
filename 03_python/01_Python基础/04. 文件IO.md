##### IO

数据一旦发生流动，就涉及到两端的操作，即数据源和目的地。在开发中，站在程序的角度，以程序为中心，从数据源获取、读取数据进行分析，称之为输入 Input；而将程序的数据保存起来，则称之为输出Output ,涉及到 Input和Output简称为 IO(Input Stream/Output Stream)操作，即读写操作。

##### 文件IO

###### 读取

​	1 、打开源文件
		2 、读取文件内容部分读取、分段读取、完整读取
		3 、操作
		4 、关闭

```
my_file = open(r'F:\shsxt\python\06_python.pdf','r')
data=my_file.read() # 一次性 读完整个文件 文件指针在结尾

data=my_file.read(2) # 一次读两个字符 
文件指针在第二个字符后面

for item in data:
    print(item)
# 一次性读取一个字符


while True:
    data=my_file.read(2)   # 一次读取两个字符 你读取字符就是字符数，如果你加上b 以字节读取就是字节数

    if not data:
        break
    print(data)

data=my_file.readline() # 一次读取一行 包含换行符

data=my_file.readline(2) # 读取一行中的几个字符

data=my_file.readlines() # 读取所有行 返回一个列表
```

二进制读取

```
file=open(r'd:\test.png','rb')
data=file.read()  # 一次读取整个文件

data=file.read(2) # 一次读取2个字节
```

###### 写入

​	1、打开目的文件
		2、准备内容
		3、写出到文件
		4、关闭

```
写文件
data='Hello'
file=open(filename,'w',encoding='utf8')
file.write(data)   # 会覆盖原来文件，没有则新建

追加
data='Hello'
file=open(filename,'a')
file.write(data) # 追加到原来文件里面

二进制写入
data='你好'.encode('uft8')  #   bytes 类型
file=open(file_name,'wb')
file.write(data)

二进制追加
data='你好'.encode('uft8')  #   bytes 类型
file=open(file_name,'ab')
file.write(data)
```

------

```
模式	可做操作	 若文件不存在	是否覆盖
r	     只能读		报错		-
r+	     可读可写		报错	   是
w	     只能写	    创建		是
w+　	 	可读可写	  创建       是
a　		只能写	       创建	    否，追加写
a+	     可读可写	   创建	    否，追加写
```

```
encoding:指定字符集，或默认编码是平台相关的（无论 locale.getpreferredencoding()返回）

errors:非二进制下使用处理错误策略，如'strict'(默认)、'ignore'(推荐)、'replace'等

newline:None \n \r \r\n 用于区分换行符，只对文本模式有效；

closefd：是否为文件，默认情况下为 True，传入的 file参数为文件的文件名，取值为 False 的时候，file 只能是文件描述符(终端)
```

###### with

```
with open("test.txt", 'a', encoding="utf-8") as f:
	c = f.write("中文")
	print("写入字节数：%d" % c)
	
with open("first.txt", 'r', encoding="utf-8") as src,
	open("second.txt", 'a', encoding="utf-8") as dest:
	for x in src.readlines():
	dest.write(x)
```

###### 内存读取写

```
from io import BytesIO
from io import SringIo

字符串和字节类似
读

with BytesIO(b'abc') as b:
    data=b.read()
写

with Bytes() as b:
    b.write(b'abc')
    print(b.getvalue())  读取内存中的内容
```

###### 定位读取

```
f=open()
f.seek(3,0)   # 3表示相对于起点的偏移量 第二个参数
0 表示从文件起点开始
1 表示从当前位置开始
2 表示从文件末尾开始

如果要使用 seek(5,1) 就是 后面使用非0 的参数那么就要用 二进制的方式读取文件

f.tell()  # 返回当前的位置
```

##### os模块

系统

```
import os
os.name  # 系统名称
e=os.environ # 环境变量
os.system()   # 执行系统命令
os.popen()    # 执行系统命令
print(e.get('path'))
```

目录操作

```
os.listdir()    # 列出当前目录的文件
os.listdir('.') # 列出当前目录的文件
os.listdir('..')# 返回父目录名称
os.path.abspath('.') # 返回当前目录的绝对路径
括号里面必须要加参数
os.mkdir('test')  # 新建文件夹
```

其他

```
os.path.exists('a.txt')
os.path.split(r'\123\456\test.txt'') # 路径一分为二
os.path.join(dir,file)  # 跨平台文件名称连接
```

删除

```
os.remove('test.txt')   # 删除文件
os.rmdir('删除空目录')
```

重命名

```
os.rename(old_name,new_name)
```

遍历目录

```
os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])  -->生成器
paths = os.walk(r'D:\000_laopei_python',onerror=None)
print(next(paths))

# 获取了指定目录的所有路径
import os
for root, dirs, files in os.walk(r"D:\000_laopei_python\day10", topdown=False):
    for name in files:
        print(os.path.join(root, name))
    for name in dirs:
        print(os.path.join(root, name))


root 是当前目录名称、dirs 是当前目录下的子目录列表、files是当前目录下的文件列表
```

shutil模块

shutil 是针对 os 模块操作文件的补充，包含有比如文件的拷贝、删除、文件移动等功能 import shutil

```
shutil.copyfile(src,dest) # 文件复制
```

pickle序列化与反序列化

我们刚刚使用 StringIO 把数据写入到了内存，或者我们使用 file.read()将数据读取到内存中，但如果一旦程序结束，这些数据都将会被删除，因此我们需要把这些数据保存到磁盘，那这个过程就叫序列化到磁盘即现将对象转化成二进制，在保存到文件，反之，如果从磁盘中读取这些数据叫反序列化。在 Python 中我们叫做 pickling

```
import pickle
L=[1,2,3,4]
# 序列化到文件  文件是二进制写入模式 wb
with open(r'C:\Users\Stefan Salvatore\Desktop\1.txt','wb') as f:
    pickle.dump(L,f)
    
# 序列化到内存 
L=[1,2,3]
msg=pickle.dumps(L)    # msg是存对象的内存

---------------------------------------------
    
2、反序列化

# 从文件反序列化 文件是二进制读取模式 rb
with open(r'C:\Users\Stefan Salvatore\Desktop\1.txt','rb') as f:
    data=pickle.load(f)
    print(data)
    

# 从内存反序列化

data=pickle.loads(msg)   # msg是之前的的内存
print(data)
```

json文件传输格式

​	序列化

```
# 序列化到文件 文件是字符串写入模式 w  文件内存是 [1,2,3] 的字符串
L=[1,2,3]
with open(r'C:\Users\Stefan Salvatore\Desktop\1.txt','w') as f:
    json.dump(L,f)
    
# 序列化到内存 
L=[1,2,3]
msg=json.dumps(L)   # msg是内存

# 序列化对象
```

​	反序列化

```
# 从文件反序列化


with open(r'C:\Users\Stefan Salvatore\Desktop\1.txt','r') as f:
    data=json.load(f)
    print(data)
```

```
# 从内存反序列化
data=json.loads(msg)
print(data)
```

