## 1、建表

```python
from django.contrib.auth.models import User
class UserProfile(models.Model):
    """用户信息表"""
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    name = models.CharField(max_length=64, verbose_name="姓名")
    role = models.ManyToManyField("Role", blank=True)

    def __str__(self):  # __unicode__
        return self.name
```

SmallIntegerField 0-65535 16位

on_delete = models.CASCADE

## 2、页面设计

STATICFILES_DIRS = [os.path.join(BASE_DIR,'static'),]

使用继承{% extends 'base.html' %}，{% block body %}{% endblock body %}



## 3、登录、退出

```python
user = authenticate(username=username,password=password)
# 如果验证成功，返回的是用户对象
# 不成功返回None

if user:
    # print('验证成功',user)
    login(request,user) # 生成session，真正的登录
    return redirect('/crm/')
    # print(username,password)
    
没有登录的时候不能到达index界面
使用装饰器@login_required
LOGIN_URL = '/login/'
login(request, user)  # 生成session,真正的登录



def acc_logout(request):
    logout(request)
    return redirect('/login/')
```

## 4、首页动态菜单

OneToOne的反向查找：request.user.userprofile 后面跟小写表名

ForeigKey的反向查找：request.user.userprofile_set 后面跟小写表名+_set

#### 模仿Django

ennabled_admins = {

​	app_name：{表名：自定义类}

}

#### 实现热插拔

```
...
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates'),
            os.path.join(BASE_DIR, 'useradmin/templates'),
                 ]
...
STATICFILES_DIRS = [
    os.path.join(BASE_DIR,'static'),
    os.path.join(BASE_DIR,'useradmin/static'),
]
...
```

#### 获取django中settings.py

```
from django import conf
conf.settings.INSTALLED_APPS
```

###### 获取自定义配置文件

```
def app_index(request):
    # print(conf.settings.INSTALLED_APPS)
    for app_name in conf.settings.INSTALLED_APPS:
        # mod = importlib.import_module(app_name, 'useradmin')
        try:
            mod = __import__("%s.useradmin"%app_name)
            print(mod.useradmin)
        except ImportError:
            pass
    return render(request, 'useradmin/app_index.html')
```

此时注册的app名字要中app名，而不是app.xxxx

###### 获取表名

```python
class AdminSite(object):
    def __init__(self):
        self.enabled_admins = {}

    def register(self, model_class, admin_class=None):
        """注册admin表"""
        print(model_class, admin_class)


site = AdminSite()


crm/useradmin.py

from useradmin.sites import site
from crm import models

print('crm useradmin ...')


class CustomerAdmin(object):
    list_display = ['name', 'contact', 'contact_type', 'source', 'consultant', 'consult_content', 'status',
                    'date']  # 显示字段
    list_filter = ['source', 'consultant', 'status', 'date']  # 过滤字段
    # search_fields = ['name', 'contact', 'consultant']  # 可搜索字段，由于有外键关联的字段，所以必须写明是外键的哪个字段
    search_fields = ['name', 'contact', 'consultant__name']

site.register(models.CustomerInfo, CustomerAdmin)
```

#### 程序运行时就获取settings.py内容

```
from useradmin import app_setup

app_setup.useradmin_auto_discover()   # 程序一运行就会调用这个函数
```

app_setup.py

```
from django import conf


def useradmin_auto_discover():

    for app_name in conf.settings.INSTALLED_APPS:
        # mod = importlib.import_module(app_name, 'kingadmin')
        try:
            mod = __import__("%s.useradmin" % app_name)
            # print(mod.useradmin)
        except ImportError:
            pass
```

#### 时间格式的处理

```python
	time_list = [
            ['', '---------'],
            [time_obj, 'Today'],
            [time_obj - datetime.timedelta(7), '七天内'],
            [time_obj.replace(day=1), '本月内'],
            [time_obj - datetime.timedelta(90), '三个月内'],
            [time_obj.replace(month=1, day=1), '本年内'],
            ['', 'All'],
        ]

        for i in time_list:
            selected = ''
            # 由于有'' 的存在，所以要做一个判断
            time_to_str = '' if not i[0] else "%s-%s-%s" % (i[0].year, i[0].month, i[0].day)
            if "%s__gte"%filter_column in admin_class.filter_conditions:  # 当前字段被过滤
                if time_to_str == admin_class.filter_conditions.get("%s__gte"%filter_column):  # 当前值被选中
                    selected = 'selected'
                    option = '<option value = "%s" %s>%s</option>' % (time_to_str, selected, i[1])
                    filter_ele += option
```

#### 处理默认值

```
class BaseUserAdmin(object):
    list_display = []
    list_filter = []
    search_fields = []
```

#### 分页

```
querysets = admin_class.model.objects.all()
# filter_conditions中有筛选条件，赋值给admin_class
querysets, filter_conditions = get_filter_result(request, querysets)
admin_class.filter_conditions = filter_conditions

paginator = Paginator(querysets, 2)  # 获取对象，每页几个
page = request.GET.get('page')
```

```
    <div class="pagination">
        <span class="step-links">
            {% if querysets.has_previous %}
                <a href="?page={{ querysets.previons_page_number }}">previous</a>
            {% endif %}
            <span class="current">
            Page    {{ querysets.number }} of {{ querysets.paginator.num_pages }}
            </span>
            {% if querysets.has_next %}
                <a href="?page={{ querysets.next_page_number }}">next</a>
            {% endif %}

        </span>
    </div>
```

##### 遇到的BUG

页面不加载静态文件：{% load staticfiles %}

提交数据时，默认不可修改字段会报空，此时在提交的时候用js去除disabled,为了防止恶意为之，需要做后台与数据库作对比

#### 图片插件dropzone



#### 自定义权限

权限：**一个动作 = 一条权限 = 一个url + 一种请求方法(get/post/put...) + 若干个请求参数**

```
perm_dic = {

    # 'crm_table_index': ['table_index', 'GET', [], {'source':'qq'}, ],  # 可以查看CRM APP里所有数据库表
    # 'crm_table_list': ['table_obj_list', 'GET', [], {'source':'0'}],  # 此时可访问的只有http://127.0.0.1:8000/useradmin/crm/customerinfo/?source=0
    'crm_table_list': ['table_obj_list', 'GET', [], {},permission_hook.view_my_own_customers],  # 可以查看每张表里所有的数据
    'crm_table_list_view': ['table_obj_change', 'GET', [], {}],  # 可以访问表里每条数据的修改页
    'crm_table_list_change': ['table_obj_change', 'POST', [], {}],  # 可以对表里的每条数据进行修改
    'crm_table_obj_add_view': ['table_obj_add', 'GET', [], {}],  # 可以访问数据增加页
    'crm_table_obj_add': ['table_obj_add', 'POST', [], {}],  # 可以创建表里的数据

}
    
from django.core.urlresolvers import resolve
from django.shortcuts import render,redirect,HttpResponse
from kingadmin.permission_list import perm_dic
from django.conf import settings


def perm_check(*args,**kwargs):

    request = args[0]
    resolve_url_obj = resolve(request.path)
    current_url_name = resolve_url_obj.url_name  # 当前url的url_name
    print('---perm:',request.user,request.user.is_authenticated(),current_url_name)
    #match_flag = False
    match_key = None
    if request.user.is_authenticated() is False:
         return redirect(settings.LOGIN_URL)

    for permission_key,permission_val in  perm_dic.items():

        per_url_name = permission_val[0]
        per_method  = permission_val[1]
        perm_args = permission_val[2]
        perm_kwargs = permission_val[3]
        custom_perm_func = None if len(permission_val) == 4 else permission_val[4]

        if per_url_name == current_url_name: #matches current request url
            if per_method == request.method: #matches request method
                # if not  perm_args: #if no args defined in perm dic, then set this request to passed perm check
                #     match_flag = True
                #     match_key = permission_key
                # else:

                #逐个匹配参数，看每个参数时候都能对应的上。
                args_matched = False #for args only
                for item in perm_args:
                    request_method_func = getattr(request,per_method)
                    if request_method_func.get(item,None):# request字典中有此参数
                        args_matched = True
                    else:
                        print("arg not match......")
                        args_matched = False
                        break  # 有一个参数不能匹配成功，则判定为假，退出该循环。
                else:
                    args_matched = True
                               # 匹配有特定值的参数
                kwargs_matched = False
                for k, v in perm_kwargs.items():
                    request_method_func = getattr(request, per_method)
                    arg_val = request_method_func.get(k, None)  # request字典中有此参数
                    print("perm kwargs check:", arg_val, type(arg_val), v, type(v))
                    if arg_val == str(v):  # 匹配上了特定的参数 及对应的 参数值， 比如，需要request 对象里必须有一个叫 user_id=3的参数
                        kwargs_matched = True
                    else:
                        kwargs_matched = False
                        break  # 有一个参数不能匹配成功，则判定为假，退出该循环。
                else:
                    kwargs_matched = True

                # 开始匹配自定义权限钩子函数
                perm_hook_matched = False
                if perm_hook_func:
                    perm_hook_matched = perm_hook_func(request)

                match_results = [args_matched, kwargs_matched, perm_hook_matched]
                print("--->match_results ", match_results)
                if all(match_results):  # 都匹配上了
                    match_key = permission_key
                    break




    if all(match_results):
        app_name, *per_name = match_key.split('_')
        print("--->matched ",match_results,match_key)
        print(app_name, *per_name)
        perm_obj = '%s.%s' % (app_name,match_key)
        print("perm str:",perm_obj)
        if request.user.has_perm(perm_obj):
            print('当前用户有此权限')
            return True
        else:
            print('当前用户没有该权限')
            return False

    else:
        print("未匹配到权限项，当前用户无权限")





def check_permission(func):
    def inner(*args,**kwargs):
        if not perm_check(*args,**kwargs):
            request = args[0]
            return render(request,'kingadmin/page_403.html')
        return func(*args,**kwargs)
    return  inner
```

```
def view_my_own_customers(request):
    print("running permisionn hook check.....")
    return True
    # if str(request.user.id) == request.GET.get('consultant'):
    #     print("访问自己创建的用户,允许")
    #     return True
    # else:
    #     return False
```

