很久很久以前，有一位国王拥有5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人人数也不同。例如有的金矿储量是500kg黄金，需要5个工人来挖掘；有的金矿储量是200kg黄金，需要3个工人来挖掘....

如果参与挖矿的工人的总数是10，每座金矿要么全挖，要么不挖，不能派出一半人挖取一半的金矿。想要得到尽可能多的黄金，应该选择挖取哪几座金矿？

###### 思路

首先，对于金矿来说，每一个金矿都存在着挖和不挖两种选择

假设如果最后一个金矿注定不被挖掘，那么问题会简化成10个工人在前4个金矿中做出的最优选择

<img src="http://silencew.cn/uploads/1574826513342.png" style="zoom:80%;" />

相应的，假设最后一个金矿一定会被挖掘，那么问题就会被简化成7个工人在前4个金矿中作出最优选择

<img src="http://silencew.cn/uploads/1574826636463.png" style="zoom:80%;" />

现在就要看10个工人在前4个金矿的收益和7个工人在前4个金矿的收益+最后一个金矿的收益哪个大了。

同样的道理，对于前4个金矿还可以进一步简化。

对于10个工人4个金矿这个子结构，第4个金矿(300kg黄金/4人)可以选择挖与不挖。根据第4个金矿的选择，问题有简化成了两个更小的子结构。

1. 10个工人在前3个金矿中作出最优选择
2. 6（10-4=6）个工人在前3个金矿中作出最优选择

相应的

1. 7个工人在前3个金矿中做出最优选择
2. 3个工人在前三个金矿中做出最优选择

最后简化成0个金矿或者0个工人时的最优选择，这个收益结果显然是0，也就是问题的边界

这就是动态规划的要点：**确定全局最优解和最优子结构之间的关系，以及问题的边界。**数学公式叫状态转移方程式

我们把金矿的数量设为n，工人数量设为w、金矿的含金量设为数组g[]，金矿所需开采人数设为数组p[]，设F(n, w)为n个金矿，w个工人时的最优收益函数，那么状态转移方程式如下

`F(n, w) = 0(n=0或w=0)`

问题边界，金矿数为0或工人数为0的情况。

`F(n, w) = F(n-1, w)  (n>=1, w<p[n-1])`

当所剩工人不够挖掘当前金矿时，只有一种最优子结构

`F(n, w) = max(F(n-1, w), F(n-1, w-p[n-1])+g[n-1]) (n>=1, w>=p[n-1])`

在常规情况下，具有两种最优子结构（挖当前金矿或不挖当前金矿）。



动态规划的另一个核心要点，自底向上求解

######代码

```java
/*
* 获得金矿的最优收益
* @param w 工人数量
* @param p 金矿开采所需的工人数量
* @param g 金矿储量
*/
public static int getBestGlodMiningV2(int w, int[] p, int[] g){
	// 创建表格
	int[][] resultTable = new int[g.length+1][w+1];
	// 填充表格
	for (int i = 1; i<= g.length; i++){
		for (int j=1; j<= w; j++){
            if (j<p[i-1]){
                resultTable[i][j] = resultTable[i-1][j];
            } else {
                resultTable[i][j] = Math.max(resultTable[i-1][j], resultTable[i-1][j-p[i-1]] + g[i-1]);
            }
        }
	}
    // 返回最后一个格子的值
    return resultTable[g.length][w];
}
```

时间复杂度和空间复杂度都是`O(nw)`

######优化

```java
/*
* 获得金矿最优收益
* @param w 工人数量
* @param p 金矿开采所需的工人数量
* @param g 金矿储量
*/
public static int getBestGoldMiningV3(int w, int[] p, int[] g){
	// 创建当前结果
	int[] results = new int[w+1];
	// 填充一维数组
	for (int i=1; i<g.length; i++){
		for (int j=w; j>=1; j--){
			if (j>=p[i-1]){
				result[j] = Math.max(results[j], results[j-p[i-1]] + g[i+1]);
			}
		}
	}
	// 返回最后1个格子的值
	return results[w];
}

```

空间复杂度降低到了`O(n)`