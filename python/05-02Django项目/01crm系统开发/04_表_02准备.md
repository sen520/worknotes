由于这个模块我们要实现的是django-admin类似功能，所以取名为useradmin

获取显示app、表

### 0、思路

ennabled_admins = {

​	app_name：{表名：自定义类}

}

### 1、新建模块

控制台输入`python manage.py startapp useradmin`创建一个新的app模块

之后在settings.py中的INSTALLED_APPS注册这个app

```python
...
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'crm.apps.CrmConfig',
    'useradmin.apps.UseradminConfig',
]
...
```

### 2、实现热插拔

由于模块的低耦合性，我们期望使得模块具有热插拔的性能。

在useradmin下新建templates、static文件夹

将根目录下的static文件夹中的内容copy到useradmin/static目录下，根目录下的templates中`base.html、login.html、index.html` copy到useradmin/templates下

### 3、配置

#### ① crm_sys/settings.py中配置static、templates

```python
...
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates'),
            os.path.join(BASE_DIR, 'useradmin/templates'),
                 ]
...
STATICFILES_DIRS = [
    os.path.join(BASE_DIR,'static'),
    os.path.join(BASE_DIR,'useradmin/static'),
]
...
```

#### ② 配置url

crm_sys/urls.py

```python
urlpatterns = [
    path('admin/', admin.site.urls),
    path('crm/',include('crm.urls')),
    path('useradmin/',include('useradmin.urls')),
    path('login/',views.acc_login),
    path('logout/',views.acc_logout,name='logout'),
]

```

在useradmin下新建urls.py

```python
from django.urls import path
from . import views

urlpatterns = [
    path('login/',views.acc_login),
    path('logout/',views.acc_logout,name='logout'),
]
```

#### ③ 配置视图文件

将crm_sys/views.py中内容copy到useradmin/views.py

```python
from django.shortcuts import render, redirect
from django.contrib.auth import authenticate, login, logout


# Create your views here.
def acc_login(request):
    error_message = ''
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')

        user = authenticate(username=username, password=password)
        # 如果验证成功，返回的是用户对象
        # 不成功返回None

        if user:
            login(request, user)  # 生成session,真正的登录
            # print(request.GET.get('next'))
            return redirect(request.GET.get('next', '/crm/'))
        else:
            error_message = 'username or password is error'
    return render(request, 'login.html', {'error_message': error_message})


def acc_logout(request):
    logout(request)
    return redirect('/login/')
```

将useradmin/templates/login.html 中的h2改为UserAdmin

这时候访问http://127.0.0.1:8000/useradmin/login/可以发现访问的还是原页面，这是因为在settings.py中第一个为根目录下的templates，在访问的时候，由于根目录templates中有login.html所以就直接返回。

解决：

​	在useradmin/templates下新建useradmin目录，把界面放到该目录下，

​	修改每个界面继承为useradmin下，{% extends 'useradmin/base.html' %}

修改useradmin/views.py

```python
...    
def acc_login(request):
    error_message = ''
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')

        user = authenticate(username=username, password=password)
        # 如果验证成功，返回的是用户对象
        # 不成功返回None

        if user:
            login(request, user)  # 生成session,真正的登录
            # print(request.GET.get('next'))
            return redirect(request.GET.get('next', '/useradmin/'))
        else:
            error_message = 'username or password is error'
    return render(request, 'useradmin/login.html', {'error_message': error_message})
...
```

此时再访问就OK了。

#### ④ 配置html界面

useradmin/urls.py

```python
...
path('',views.app_index,name='app_index'),
...
```

useradmin/views.py

```
...
def app_index(request):
    return render(request,'useradmin/app_index.html')
```

新建useradmin/templates/useradmin/app_index.html

修改useradmin/templates/useradmin/index.html

```html
...
<div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main">
{% block right-content-container %}
{#<h2 class="page-header">Dashboard</h2>#}
{% endblock right-content-container %}
</div>
...
```

useradmin/templates/useradmin/app_index.html

```html
{% extends 'useradmin/index.html' %}
{% block right-content-container %}
    <h2 class="page-header">App</h2>
{% endblock right-content-container %
```

这样就可以正常显示了

![04_03 App效果图](./img/04_03%20App%E6%95%88%E6%9E%9C%E5%9B%BE.png)

#### ⑤获取settings配置

useradmin/views.py

```
from django import conf
...
# Create your views here.

def app_index(request):
    # print(conf.settings.INSTALLED_APPS)
    return render(request, 'useradmin/app_index.html')
...
```

这样就可以获取到当前所有的app

模仿django/settings在crm下新建useradmin.py

```python
print('useradmin....')
```

useradmin/views.py

```python
...
import importlib


# Create your views here.

def app_index(request):
    # print(conf.settings.INSTALLED_APPS)
    for app_name in conf.settings.INSTALLED_APPS:
        # mod = importlib.import_module(app_name, 'useradmin')
        try:
            mod = __import__("%s.useradmin"%app_name)
            print(mod.useradmin)
        except ImportError:
            pass
    return render(request, 'useradmin/app_index.html')
...
```

刷新页面会发现No module named 'crm.apps.CrmConfig'; 'crm.apps' is not a package，

所以在settings.py中更改注册的app名

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'crm',
    'useradmin',
]
```

之后再运行，会发现打印

```
crm useradmin ...
<module 'crm.useradmin' from 'E:\\Python\\exe\\01django\\crm_sys\\crm\\useradmin.py'>
```

#### ⑥获取表名

新建app student 记得在settings.py中注册

模仿django，在useradmin下新建sites.py文件

```python
class AdminSite(object):
    def __init__(self):
        self.enabled_admins = {}

    def register(self, model_class, admin_class=None):
        """注册admin表"""
        print(model_class, admin_class)


site = AdminSite()

```

crm/useradmin.py

```python
from useradmin.sites import site
from crm import models

print('crm useradmin ...')


class CustomerAdmin(object):
    list_display = ['name', 'contact', 'contact_type', 'source', 'consultant', 'consult_content', 'status',
                    'date']  # 显示字段
    list_filter = ['source', 'consultant', 'status', 'date']  # 过滤字段
    # search_fields = ['name', 'contact', 'consultant']  # 可搜索字段，由于有外键关联的字段，所以必须写明是外键的哪个字段
    search_fields = ['name', 'contact', 'consultant__name']

site.register(models.CustomerInfo, CustomerAdmin)
```

创建useradmin/app_setup.py，使得在程序运行的时候就执行⑤中获取settings.py内容的操作

将useradmin/views.py中部分剪切到app_setup.py中

useradmin/views.py

```python
...
from useradmin import app_setup

app_setup.useradmin_auto_discover()   # 程序一运行就会调用这个函数
...
def app_index(request):
    # print(conf.settings.INSTALLED_APPS)
    # enable_admins =
    return render(request, 'useradmin/app_index.html')
...
```

app_setup.py 获取表名

```python
from django import conf


def useradmin_auto_discover():

    for app_name in conf.settings.INSTALLED_APPS:
        # mod = importlib.import_module(app_name, 'kingadmin')
        try:
            mod = __import__("%s.useradmin" % app_name)
            print(mod.useradmin)
        except ImportError:
            pass
```

在student下新建useradmin.py  实现注册

```python
from useradmin.sites import site
from student import models

print('student useradmin ...')


class TestAdmin(object):
    list_display = ['name']  # 显示字段


site.register(models.Test, TestAdmin)
```

新建一个测试表

student/models.py

```
class Test(models.Model):
    name = models.CharField(max_length=64)
```



#### ⑦获取app名

在注册中查看表名，如果不在系统中，就添加。

useradmin/sites.py

```python
class AdminSite(object):
    def __init__(self):
        self.enabled_admins = {}

    def register(self, model_class, admin_class=None):
        """注册admin表"""
        print(model_class, admin_class)

        app_name = model_class._meta.app_label  # 获取系统中的app
        model_name = model_class._meta.model_name

        if app_name not in self.enabled_admins:
            self.enabled_admins[app_name] = {}
        self.enabled_admins[app_name][model_name] = admin_class


site = AdminSite()
```

此时就会发现，按照程序的运行，每个模块在调用的时候就会实例化一次，创建两个空字典，按照我们预期的想法，应该存放到一个字典中

useradmin/views.py

```python
from django.shortcuts import render, redirect
from django.contrib.auth import authenticate, login, logout
from django import conf
from useradmin import app_setup

app_setup.useradmin_auto_discover()

from useradmin.sites import site
print('sites',site.enabled_admins)
...
```

运行结果：

​	sites {'crm': {'customerinfo': \<class 'crm.useradmin.CustomerAdmin'>}, 'student': {'test': \<class 'student.useradmin.TestAdmin'>}}

惊讶的发现竟然放在的一个字典中，也就是说再次调用的时候根本没有再实例化，都只是调用了前面实例化的对象。

这样准备工作就做好了。