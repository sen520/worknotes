### 1、实现

useradmin/views.py

```python
...
def app_index(request):

    return render(request, 'useradmin/app_index.html',{'site':site})
...
```

useradmin/templates/useradmin/app_index.html

```html
   ...
    <h2 class="page-header">App</h2>
    <div>
        {% for app_nam,app_tables in site.enabled_admins.items %}

            {{ app_name }} {{ app_tables }}

        {% endfor %}

    </div>
    ...
```

![04_04 前端效果图01](./img/04_04%20%E5%89%8D%E7%AB%AF%E6%95%88%E6%9E%9C%E5%9B%BE01.png)

useradmin/templates/useradmin/app_index.html

```html
{% extends 'useradmin/index.html' %}

{% block right-content-container %}

    <h2 class="page-header">App</h2>
    <div>
        {% for app_name,app_tables in site.enabled_admins.items %}
            <table class="table table-striped">
                <thead>
                <tr>
                    <th>
                        {{ app_name }}
                    </th>
                </tr>
                </thead>
                <tbody>
                {% for model_name in app_tables %}
                    <tr>
                        <td><a href="{% url 'table_obj_list' app_name model_name %}">{{ model_name }}</a></td>
                                                <td><a href="/useradmin/{{ app_name }}/{{ model_name }}/add">ADD</a></td>
                        <td>Change</td>
                    </tr>
                {% endfor %}
                </tbody>
            </table>
        {% endfor %}

    </div>



{% endblock right-content-container %}

```

为了展示效果，再多注册几个表

crm/useradmin.py

```python
...
site.register(models.CustomerInfo, CustomerAdmin)
site.register(models.Role)
site.register(models.Menus)
site.register(models.UserProfile)
```

![04_04 前端效果图02](./img/04_04%20%E5%89%8D%E7%AB%AF%E6%95%88%E6%9E%9C%E5%9B%BE02.png)

### 2、表的详细信息

#### ①获取注册表和信息（自定义类）

```html
<tbody>
    {% for model_name in app_tables %}
    <tr>
        <td><a href="{% url 'table_obj_list' app_name model_name %}">{{ model_name }}</a></td>
        <td>ADD</td>
        <td>Change</td>
    </tr>
    {% endfor %}
</tbody>
```

##### 1、配置url

useradmin/urls.py

```python
...
	path('<str:app_name>/<str:model_name>', views.table_obj_list, name='table_obj_list'),
...
```

##### 2、useradmin/views.py

```python
...
from django.contrib.auth.decorators import login_required
...
@login_required
def table_obj_list(request, app_name, model_name):
    """取出指定的model里的数据返回给前端"""
    print('app_name,model_name:',site.enabled_admins[app_name][model_name])
...

```

运行，控制台打印出了自定义的类

app_name,model_name:\<class 'crm.useradmin.CustomerAdmin'>



##### 3、将model_class 和admin_class 绑定

useradmin/sites.py

```python
...
model_name = model_class._meta.model_name
admin_class.model = model_class

if app_name not in self.enabled_admins:
self.enabled_admins[app_name] = {}
self.enabled_admins[app_name][model_name] = admin_class # 把model_class 给了admin_class
...
```

由于注册的时候可能没有传入自定义的类，会报异常，所以需要自定义一个基类，使得没有传入的时候会有一个默认值

在useradmin下新建admin_base.py

```python
class BaseUserAdmin(object):
    pass
```

crm/useradmin.py

```python
...
from useradmin.sites import site
from useradmin.admin_base import BaseUserAdmin
...
class CustomerAdmin(BaseUserAdmin):
...
```

useradmin/sites.py

```python
from useradmin.admin_base import BaseUserAdmin
...
	def register(self, model_class, admin_class=BaseUserAdmin):
...
```

增加这个基类的好处还在于表中扩展时会很方便的实现

在useradmin/views.py中添加一条打印语句

```python
    ...
    print('app_name,model_name:',site.enabled_admins[app_name][model_name])
    admin_class = site.enabled_admins[app_name][model_name]
    print('admin_class',admin_class.model)
    ...
```

再次执行，刷新http://127.0.0.1:8000/useradmin/crm/customerinfo界面

控制台会打印

​	app_name,model_name: \<class 'crm.useradmin.CustomerAdmin'>
		admin_class \<class 'crm.models.CustomerInfo'>

没有自定义类的http://127.0.0.1:8000/useradmin/crm/menus

​	app_name,model_name: \<class 'useradmin.admin_base.BaseUserAdmin'>
		admin_class \<class 'crm.models.UserProfile'>

这样就获取到了所有的类



##### 4、配置内部页面

###### 1）配置初始页面

useradmin/views.py

```python
...
@login_required
def table_obj_list(request, app_name, model_name):
    """取出指定的model里的数据返回给前端"""
    print('app_name,model_name:',site.enabled_admins[app_name][model_name])
    admin_class = site.enabled_admins[app_name][model_name]
    print('admin_class',admin_class.model)
    quersets = admin_class.model.objects.all()
    return render(request,'useradmin/table_obj_list.html',{'querysets':querysets})
...
```

useradmin/templates/useradmin新建table_obj_list.html

```html
{% extends 'useradmin/index.html' %}

{% block right-content-container %}

    <h2 class="page-header">App</h2>
    {{ querysets }}
{% endblock right-content-container %}
```

###### 2）解决BUG

http://127.0.0.1:8000/useradmin/ 点击每个表名，结果发现除了有自定义类的外，显示的数据是一样的，原因是基类导入了一次数据后，其他的调用时都用了最后一次导入的数据

证明：

useradmin/views.py

```python
...
app_setup.useradmin_auto_discover()

from useradmin.sites import site
# print('sites', site.enabled_admins)
for k,v in site.enabled_admins.items():
    for table_name,admin_class in v.items():
        print(table_name,id(admin_class))
...
```

运行结果

```
customerinfo 1803922624904
role 1803922613576
menus 1803922613576
userprofile 1803922613576
test 1803922626792
```

解决方法：先实例化后再做操作

useradmin/sites.py

```python
...
class AdminSite(object):
    def __init__(self):
        self.enabled_admins = {}

    def register(self, model_class, admin_class=None):
        """注册admin表"""
        # print(model_class, admin_class)

        app_name = model_class._meta.app_label  # 获取系统中的app
        model_name = model_class._meta.model_name

        if not admin_class:# 为了避免多个model共享同一个BaseUserAdmin内存对象
            admin_class = BaseUserAdmin()
        else:
            admin_class = admin_class()
        admin_class.model = model_class  # 把model_class 赋值给了admin_class
...
```

###### 3）格式化展示页面

要把数据获取到，并显示到页面上，首先我们先获取到自定义类的字段，也就是后台把admin_class返回即可

useradmin/views.py

```python
    admin_class = site.enabled_admins[app_name][model_name]
    # print('admin_class',admin_class.model)
    querysets = admin_class.model.objects.all()

    return render(request,'useradmin/table_obj_list.html',{'querysets':querysets,'admin_class':admin_class})
```

table_obj_list.html

```html
    <h2 class="page-header">App</h2>
{#    {{ querysets }}#}
    <div>

            <table class="table table-striped">
                <thead>
                <tr>
                        {% for column in admin_class.list_display %}
                            <th>{{ column }}</th>
                        {% endfor %}
                </tr>
                </thead>
                <tbody>
                    {% for obj in querysets %}
                       <tr>{% build_table_row obj admin_class %}</tr>
                    {% endfor %}
                </tbody>
            </table>
```

运行，浏览器链接http://127.0.0.1:8000/useradmin/crm/customerinfo可以查看效果

要在obj中显示column上的对应字段，要采用反射的手段，此时我们需要自定义一个标签

在useradmin下新建python packages-----templatetags，在该目录下新建useradmin_tags.py

我们在获取内容的时候，不选择字段一个个遍历，而是采用后台一次返回一整行的方式

useradmin/templatetags/useradmin_tags.py

```python
from django.template import Library

register = Library()


@register.simple_tag
def build_table_row(obj,admin_class):
    """生成一条记录的html element"""

    ele = ''
    for column_name in admin_class.list_display:
        column_data = getattr(obj,column_name)
        td_ele = '<td>%s</td>'%column_data
        ele += td_ele

    return ele
```

在table_obj_list.html第二行加上`{% load useradmin_tags %}`即可

注意：此时运行需要重启程序才可以，否则会报错，因为django无法自主找到自定义的标签

此时运行：

![04_04 前端效果图03](./img/04_04%20%E5%89%8D%E7%AB%AF%E6%95%88%E6%9E%9C%E5%9B%BE03.png)

发现是原样显示在浏览器上的，这时需要一个mark_safe()

修改useradmin_tags.py

```python
from django.template import Library
from django.utils.safestring import mark_safe

register = Library()


@register.simple_tag
def build_table_row(obj,admin_class):
    """生成一条记录的html element"""

    ele = ''
    for column_name in admin_class.list_display:
        column_data = getattr(obj,column_name)
        td_ele = '<td>%s</td>'%column_data
        ele += td_ele

    return mark_safe(ele)
```

刷新之后就显示出我们要的画面了

![04_04 前端效果图04](./img/04_04%20%E5%89%8D%E7%AB%AF%E6%95%88%E6%9E%9C%E5%9B%BE04.png)



修改bug：

​	上面画面的status...等显示的是数字，而不是文本

​	使用get\_字段\_display方法，首先先判断哪个字段需要这个方法，通过models.CustomerInfo._meta.fields获取model所有字段对象，取到其中一个字段的对象choices字段models.CustomerInfo.\_meta.fields.get\_field('status').choices可以获取到元组，使用name对象的choices字段是否为空就可以来判断了，为空就不是

useradmin_tags.py

```python
...
@register.simple_tag
def build_table_row(obj,admin_class):
    """生成一条记录的html element"""

    ele = ''
    for column_name in admin_class.list_display:
        colum_obj = admin_class.model._meta.get_field(column_name)
        if colum_obj.choices: # get_xxx_display
            column_data = getattr(obj,'get_%s_display'%column_name)() # 获取对象中的方法
        else:
            column_data = getattr(obj,column_name)
        td_ele = '<td>%s</td>'%column_data
        ele += td_ele

    return mark_safe(ele)
```

这样就完美搞定

![04_04 前端效果图05](E:/%E6%80%BB%E7%BB%93/note/05-03crm%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/img/04_04%20%E5%89%8D%E7%AB%AF%E6%95%88%E6%9E%9C%E5%9B%BE05.png)

###### 4）过滤功能(前端展示)

首先观察django中在过滤条件的时候url变化

无过滤条件：http://127.0.0.1:8000/admin/crm/customerinfo/

单个过滤条件：http://127.0.0.1:8000/admin/crm/customerinfo/?source__exact=0

多个过滤条件：http://127.0.0.1:8000/admin/crm/customerinfo/?consultant\_\_id\__exact=2&source__exact=0

过滤界面以下拉方式展示

table_obj_list.html

```html
{% extends 'useradmin/index.html' %}
{% load useradmin_tags %}
{% block right-content-container %}

    <h2 class="page-header">App</h2>
    {#    {{ querysets }}#}
    <div>
        <form action="">
            {% for filter_column in admin_class.list_filter %}
                {% build_filter_ele filter_column admin_class %}
            {% endfor %}
            <input type="submit" value="确定">
        </form>


    </div>
    <div>

        <table class="table table-striped">
        ...
```

useradmin_tags.py

```python
@register.simple_tag
def build_filter_ele(filter_column,admin_class):
    filter_ele = "<select name='%s'>"%filter_column
    column_obj = admin_class.model._meta.get_field(filter_column)
    for choice in column_obj.choices:
        option = '<option value = "%s">%s</option>'%choice
        filter_ele += option
    filter_ele += '</select>'
    return mark_safe(filter_ele)
```

此时发现外键字段没有显示

此时需要useradmin_tags.py中的choices改为get_choices()，然后会报错，我们捕获这个异常

```python
...
@register.simple_tag
def build_filter_ele(filter_column,admin_class):
    filter_ele = "<select name='%s'>"%filter_column
    column_obj = admin_class.model._meta.get_field(filter_column)
    try:
        for choice in column_obj.get_choices():
            option = '<option value = "%s">%s</option>'%choice
            filter_ele += option
    except AttributeError as e:
        print('err',e)
    filter_ele += '</select>'
    return mark_safe(filter_ele)
    ...
```

会发现只有date没有显示，就说明是date这个字段报了错

修改useradmin_tags.py

```python
    except AttributeError as e:
        print('err', e)
        if column_obj.get_internal_type() in ('DateField', 'DateTimeField'):
            time_obj = datetime.datetime.now()  # 获取时间对象
            time_list = [
                ['','---------'],
                [time_obj, 'Today'],
                [time_obj - datetime.timedelta(7), '七天内'],
                [time_obj.replace(day=1), '本月内'],
                [time_obj - datetime.timedelta(90), '三个月内'],
                [time_obj.replace(month=1, day=1), '本年内'],
                ['', 'All'],
            ]

            for i in time_list:
                option = '<option value = "%s">%s</option>' % (i[0],i[1])
                filter_ele += option

            # opt_list = []
            # opt_list.append(['%s-%s-%s'%(time_obj.year,time_obj.month,time_obj.day),'Today']) # 今天，转化固定格式
            # before7days = time_obj - datetime.timedelta(7)
            # opt_list.append(['%s-%s-%s'%(before7days.year,before7days.month,before7days.day),'七天内'])

    filter_ele += '</select>'
    return mark_safe(filter_ele)
```

###### 5）后台筛选

useradmin/views.py

```python
...

def get_filter_result(request,querysets):
    filter_conditions = {}
    for key,value in request.GET.items():
        if value:
            filter_conditions[key] = value

    print('filter_conditions',filter_conditions)
    return querysets.filter(**filter_conditions)

@login_required
def table_obj_list(request, app_name, model_name):
    """取出指定的model里的数据返回给前端"""
    # print('app_name,model_name:',site.enabled_admins[app_name][model_name])
    admin_class = site.enabled_admins[app_name][model_name]
    # print(request.GET)
    # 打印结果：<QueryDict: {'source': ['1'], 'consultant': ['2'], 'status': ['0'], 'date': ['2018-07-01 11:19:26.324492']}>
    # print('admin_class',admin_class.model)

    querysets = admin_class.model.objects.all()

    querysets = get_filter_result(request,querysets)


    return render(request, 'useradmin/table_obj_list.html', {'querysets': querysets, 'admin_class': admin_class})
...
```

运行，目前可以进行筛选了（时间字段暂为实现），但是筛选字段在筛选之后并没有显示在条件上



views.py

```python
...
def get_filter_result(request, querysets):
    filter_conditions = {}
    for key, value in request.GET.items():
        if value:
            filter_conditions[key] = value
    print('filter_conditions', filter_conditions)
    return querysets.filter(**filter_conditions),filter_conditions

...
	querysets = admin_class.model.objects.all()
    # filter_conditions中有筛选条件，赋值给admin_class
    querysets,filter_conditions = get_filter_result(request, querysets)
    admin_class.filter_conditions = filter_conditions
    ...
```

useradmin_tags.py

```python
...
    try:
        for choice in column_obj.get_choices():
            selected = ''
            if filter_column in admin_class.filter_conditions:  # 当前字段被过滤
                if str(choice[0]) == admin_class.filter_conditions.get(filter_column):  # 当前值被选中
                    selected = 'selected'
            option = '<option value = "%s" %s>%s</option>' % (choice[0],selected,choice[1])
            filter_ele += option
    except AttributeError as e:
    ...
```

###### 6）时间格式修复

useradmin_tags.py

```python
...
time_list = [
    ['', '---------'],
    [time_obj, 'Today'],
    [time_obj - datetime.timedelta(7), '七天内'],
    [time_obj.replace(day=1), '本月内'],
    [time_obj - datetime.timedelta(90), '三个月内'],
    [time_obj.replace(month=1, day=1), '本年内'],
    ['', 'All'],
]

for i in time_list:
    selected = ''
    # 由于有'' 的存在，所以要做一个判断
    time_to_str = '' if not i[0] else "%s-%s-%s" % (i[0].year, i[0].month, i[0].day)
    if filter_column in admin_class.filter_conditions:  # 当前字段被过滤
        if time_to_str == admin_class.filter_conditions.get(filter_column):  # 当前值被选中
            selected = 'selected'
    option = '<option value = "%s" %s>%s</option>' % (time_to_str, selected, i[1])
    filter_ele += option
    ...
```

目前只是解决了错误，并没有做查询处理，观察刷新页面时url，可以发现url上是=号，所以在select标签上做添加gte的处理

```python
def build_filter_ele(filter_column, admin_class):

    column_obj = admin_class.model._meta.get_field(filter_column)
    try:
        filter_ele = "<select name='%s'>" % filter_column
        for choice in column_obj.get_choices():
            selected = ''
            if filter_column in admin_class.filter_conditions:  # 当前字段被过滤
                if str(choice[0]) == admin_class.filter_conditions.get(filter_column):  # 当前值被选中
                    selected = 'selected'
            option = '<option value = "%s" %s>%s</option>' % (choice[0], selected, choice[1])
            filter_ele += option
    except AttributeError as e:
        # print('err', e)
        filter_ele = "<select name='%s__gte'>" % filter_column
        if column_obj.get_internal_type() in ('DateField', 'DateTimeField'):
```

这样虽然数据能接受到了，但是仍然看不到筛选的条件，因为我们在添加__gte的时候斌那个没有给filter_column添加，所以只要在filter_column上也添加了就ok了

```python
except AttributeError as e:
    # print('err', e)
    filter_ele = "<select name='%s__gte'>" % filter_column
    if column_obj.get_internal_type() in ('DateField', 'DateTimeField'):
        time_obj = datetime.datetime.now()  # 获取时间对象
        time_list = [
            ['', '---------'],
            [time_obj, 'Today'],
            [time_obj - datetime.timedelta(7), '七天内'],
            [time_obj.replace(day=1), '本月内'],
            [time_obj - datetime.timedelta(90), '三个月内'],
            [time_obj.replace(month=1, day=1), '本年内'],
            ['', 'All'],
        ]

        for i in time_list:
            selected = ''
            # 由于有'' 的存在，所以要做一个判断
            time_to_str = '' if not i[0] else "%s-%s-%s" % (i[0].year, i[0].month, i[0].day)
            if "%s__gte"%filter_column in admin_class.filter_conditions:  # 当前字段被过滤
                if time_to_str == admin_class.filter_conditions.get("%s__gte"%filter_column):  # 当前值被选中
                    selected = 'selected'
                    option = '<option value = "%s" %s>%s</option>' % (time_to_str, selected, i[1])
                    filter_ele += option
```

这就是有自定义显示字段等功能的表的展示

#### ②无自定义类的实现

在没有实现之前，访问这个类会报错，原因是table_obj_list.html中

```python
<tbody>
{% for obj in querysets %}
<tr>{% build_table_row obj admin_class %}</tr>
{% endfor %}
</tbody>
```

调用模板方法的时候对自定义类中的列表进行了遍历。

###### 1）解决问题

我们要在基类中设定这些列表方法的默认值

在useradmin/admin_base.py

```python
class BaseUserAdmin(object):
    list_display = []
    list_filter = []
    search_fields = []
```

###### 2）配置显示数据

useradmin_tags.py

```python
...

@register.simple_tag
def build_table_row(obj, admin_class):
    """生成一条记录的html element"""

    ele = ''
    if admin_class.list_display:
        for column_name in admin_class.list_display:
            colum_obj = admin_class.model._meta.get_field(column_name)
            if colum_obj.choices:  # get_xxx_display
                column_data = getattr(obj, 'get_%s_display' % column_name)()  # 获取对象中的方法
            else:
                column_data = getattr(obj, column_name)
            td_ele = '<td>%s</td>' % column_data
            ele += td_ele
    else:
        td_ele = '<td>%s<td>'%obj # 默认返回str方法
        ele += td_ele
    return mark_safe(ele)
```

修改前端页面table_obj_list.html

```html
    <div>
    {% if admin_class.list_filter %}
        <form action="">
            {% for filter_column in admin_class.list_filter %}
                {% build_filter_ele filter_column admin_class %}
            {% endfor %}
            <input type="submit" value="确定">
        </form>
    {% endif %}

    </div>
```

配置表名

table_obj_list.html

```html
<thead>
	<tr>
	{% if admin_class.list_display %}
		{% for column in admin_class.list_display %}
			<th>{{ column }}</th>
		{% endfor %}
	{% else %}
		{#<th>{{ admin_class.model._meta.model_name }}</th> 不能以_开头#}
		<th>{% get_model_name admin_class %}</th>
	{% endif %}
	</tr>
</thead>
```

useradmin/useradmin_tags.py

```python
...
@register.simple_tag
def get_model_name(admin_class):
    return admin_class.model._meta.model_name.upper()
```

### 3、分页

#### ①实现

作用：减少数据库和用户的IO带宽

数据库：select * from tablename limit 50 ，10  从50开始取10条

Contacts.object.all()	并不是把数据全部取出来

useradmin/views.py

```python
...
querysets = admin_class.model.objects.all()
# filter_conditions中有筛选条件，赋值给admin_class
querysets, filter_conditions = get_filter_result(request, querysets)
admin_class.filter_conditions = filter_conditions

paginator = Paginator(querysets, 2)  # 获取对象，每页几个
page = request.GET.get('page')
try:
querysets = paginator.page(page)
except PageNotAnInteger:
querysets = paginator.page(1)
except EmptyPage:
querysets = paginator.page(paginator.num_pages)

return render(request, 'useradmin/table_obj_list.html', {'querysets': querysets, 'admin_class': admin_class})
...
```

table_obj_list.html

```html
...
    <div class="pagination">
        <span class="step-links">
            {% if querysets.has_previous %}
                <a href="?page={{ querysets.previons_page_number }}">previous</a>
            {% endif %}
            <span class="current">
            Page    {{ querysets.number }} of {{ querysets.paginator.num_pages }}
            </span>
            {% if querysets.has_next %}
                <a href="?page={{ querysets.next_page_number }}">next</a>
            {% endif %}

        </span>
    </div>

{% endblock right-content-container %}
```

运行会报错的原因是该分页时url后面的参数 和 筛选的时候后面的参数 格式相同，在筛选的时候会误把该参数当做筛选条件

在筛选条件的时候做判断

useradmin/views.py

```python
def get_filter_result(request, querysets):
    filter_conditions = {}
    for key, value in request.GET.items():
        if key == '_page':
            continue
        if value:
            filter_conditions[key] = value
...
  	querysets, filter_conditions = get_filter_result(request, querysets)
    admin_class.filter_conditions = filter_conditions

    paginator = Paginator(querysets, 2)  # 获取对象，每页几个
    page = request.GET.get('_page')
    try:
        querysets = paginator.page(page)
```

table_obj_list.html

```
...
    <div class="pagination">
        <span class="step-links">
            {% if querysets.has_previous %}
                <a href="?_page={{ querysets.previons_page_number }}">previous</a>
            {% endif %}
            <span class="current">
            Page    {{ querysets.number }} of {{ querysets.paginator.num_pages }}
            </span>
            {% if querysets.has_next %}
                <a href="?_page={{ querysets.next_page_number }}">next</a>
            {% endif %}

        </span>
    </div>

{% endblock right-content-container %}
```

#### ②优化

useradmin_tags.py

```python
...
@register.simple_tag
def render_paginator(querysets):
    ele = """
        <ul class="pagination">
    """
    disabled = 'class = "disabled"'
    href = ''
    if querysets.number>1:
        previous = querysets.number - 1
        disabled = ''
        href = "href='?_page=%s'" % previous
    ele += '<li %s><a %s aria-label="Previous"><span aria-hidden="true">&laquo;</span></a></li>'%(disabled,href)

    for i in querysets.paginator.page_range:
        if abs(querysets.number - i) < 2:  # 要显示的页码范围
            active = ''
            if querysets.number == i: # current page
                active = 'active'
            p_ele = """<li class="%s"><a href="?_page=%s">%s</a></li>"""%(active,i,i)
            ele += p_ele
    ele += "</ul>"

    return mark_safe(ele)
```

table_obj_list.html

```html
    <div class="pagination">



        {% render_paginator querysets %}


{#        <span class="step-links">#}
{#            {% if querysets.has_previous %}#}
{#                <a href="?_page={{ querysets.previons_page_number }}">previous</a>#}
{#            {% endif %}#}
{#            <span class="current">#}
{#            Page    {{ querysets.number }} of {{ querysets.paginator.num_pages }}#}
{#            </span>#}
{#            {% if querysets.has_next %}#}
{#                <a href="?_page={{ querysets.next_page_number }}">next</a>#}
{#            {% endif %}#}
{##}
{#        </span>#}
    </div>
```

实现上一页、下一页的功能

useradmin_tags.py

```python
@register.simple_tag
def render_paginator(querysets):
    ele = """
        <ul class="pagination">
    """
    pre_disabled = 'class = "disabled"'
    next_disabled = 'class = "disabled"'
    pre_href = ''
    next_href =''
    if querysets.number>1:
        previous = querysets.number - 1
        pre_disabled = ''
        pre_href = "href='?_page=%s'" % previous
    ele += '<li %s><a %s aria-label="Previous"><span aria-hidden="true">&laquo;</span></a></li>'%(pre_disabled,pre_href)

    for i in querysets.paginator.page_range:
        if abs(querysets.number - i) < 2:  # 要显示的页码范围
            active = ''
            if querysets.number == i: # current page
                active = 'active'
            p_ele = """<li class="%s"><a href="?_page=%s">%s</a></li>"""%(active,i,i)
            ele += p_ele
    if querysets.has_next():
        # print(querysets.has_next)
        next = querysets.number + 1
        next_disabled = ''
        next_href = "href='?_page=%s'" % next
    # print(next_href)
    ele += '<li %s><a %s aria-label="Previous"><span aria-hidden="true">&raquo;</span></a></li>' % (next_disabled, next_href)

    ele += "</ul>"

    return mark_safe(ele)
```

此时运行会出现一个警告，是因为没有排序的原因

useradmin/views.py

```python
@login_required
def table_obj_list(request, app_name, model_name):
    """取出指定的model里的数据返回给前端"""
    # print('app_name,model_name:',site.enabled_admins[app_name][model_name])
    admin_class = site.enabled_admins[app_name][model_name]
    # print(request.GET)
    # 打印结果：<QueryDict: {'source': ['1'], 'consultant': ['2'], 'status': ['0'], 'date': ['2018-07-01 11:19:26.324492']}>
    # print('admin_class',admin_class.model)

    querysets = admin_class.model.objects.order_by('id')
    # querysets = admin_class.model.objects.all()
    # filter_conditions中有筛选条件，赋值给admin_class
    querysets, filter_conditions = get_filter_result(request, querysets)
    admin_class.filter_conditions = filter_conditions
```

### 4、排序

#### ①添加链接

table_obj_list.html

```html
<thead>
	<tr>
		{% if admin_class.list_display %}
			{% for column in admin_class.list_display %}
			<th><a href="?_o={{ forloop.counter0 }}">{{ column }}</a></th>
			{% endfor %}
		{% else %}
			{#<th>{{ admin_class.model._meta.model_name }}</th> 不能以_开头#}
			<th>{% get_model_name admin_class %}</th>
		{% endif %}
	</tr>
</thead>
```

#### ②修改过滤条件

useradmin/views.py

```python
def get_filter_result(request, querysets):
    filter_conditions = {}
    for key, value in request.GET.items():
        if key in ('_page','_o'):
            continue
        if value:
            filter_conditions[key] = value

    # print('filter_conditions', filter_conditions)
    return querysets.filter(**filter_conditions), filter_conditions
```

#### ③分页

##### 1）一种排序

为了显示排序的效果，在crm/useradmin.py中的list_display 添加id字段

crm/admin.py类中添加属性确定分页和排序的顺序：先排序后分页。

```
list_per_page = 2
```

useradmin/views.py

```python
...
def get_orderby_result(request, querysets, admin_class):
    """排序"""
    orderby_index = request.GET.get('_o')
    if orderby_index:  # 有排序
        orderby_key = admin_class.list_display[orderby_index]
        return querysets.order_by(orderby_key)
    else:
        return querysets


@login_required
def table_obj_list(request, app_name, model_name):
...
    # filter_conditions中有筛选条件，赋值给admin_class
    querysets, filter_conditions = get_filter_result(request, querysets)
    admin_class.filter_conditions = filter_conditions

    # sorted_querysets
    querysets = get_orderby_result(request, querysets, admin_class)


    paginator = Paginator(querysets, 2)  # 获取对象，每页几个
    page = request.GET.get('_page')
    ...
```

##### 2）多种排序

观察admin页面，点击一次后url会变成相反的值![04_04 预期效果01](.\img\04_04 预期效果01.png)

useradmin/views.py

```python
...
def get_orderby_result(request, querysets, admin_class):
    """排序"""

    current_ordered_column = {}
    orderby_index = request.GET.get('_o')
    if orderby_index:  # 有排序
        orderby_key = admin_class.list_display[int(orderby_index)]

        # 为了让前端知道当前的排序的列
        current_ordered_column[orderby_key] = orderby_index

        return querysets.order_by(orderby_key), current_ordered_column
    else:
        return querysets, current_ordered_column
...
    querysets, filter_conditions = get_filter_result(request, querysets)
    admin_class.filter_conditions = filter_conditions

    # sorted_querysets
    queryset, sorted_column = get_orderby_result(request, querysets, admin_class)

    paginator = Paginator(querysets, 2)  # 获取对象，每页几个
    page = request.GET.get('_page')
    try:
        querysets = paginator.page(page)
```

table_obj_list.html

```python
    ...        
    <tr>
        {% if admin_class.list_display %}
            {% for column in admin_class.list_display %}
                <th><a href="?_o={% get_sorted_column column sorted_column forloop.counter0  %}">{{ column }}</a></th>
            {% endfor %}
        {% else %}
            {#<th>{{ admin_class.model._meta.model_name }}</th> 不能以_开头#}
            <th>{% get_model_name admin_class %}</th>
        {% endif %}
    </tr>
    ...
```

useradmin_tags.py

```python
...
@register.simple_tag
def get_sorted_column(column,sorted_column,forloop):
    # sorted_column = {'name':'0(-0)'}
    if column in sorted_column:
        # 这一列被排序,需要判断上一次排序的顺序，本次取反
        last_sort_index = sorted_column[column]
        if last_sort_index.startswith('-'):
            this_time_sort_index = last_sort_index.strip('-')
        else:
            this_time_sort_index = "-%s"% last_sort_index
        return this_time_sort_index
    else:
        return forloop

...
```

这样前端链接就实现了

实现排序

useradmin/views.py

```python
def get_orderby_result(request, querysets, admin_class):
    """排序"""

    current_ordered_column = {}
    orderby_index = request.GET.get('_o')
    if orderby_index:  # 有排序
        orderby_key = admin_class.list_display[abs(int(orderby_index))]

        # 为了让前端知道当前的排序的列
        current_ordered_column[orderby_key] = orderby_index

        if orderby_index.startswith('-'):
            orderby_key = '-' + orderby_key
        # print("==========")
        # print(orderby_key)
        # print(querysets.order_by(orderby_key))
        return querysets.order_by(orderby_key), current_ordered_column
    else:
        # print('---------')
        return querysets, current_ordered_column

```

排序功能实现，加个排序标志

将bootstrap的字体包拷贝到useradmin/static/fonts

useradmin_tags.py

```python
...
@register.simple_tag
def render_sorted_arrow(column,sorted_column):
    if column in sorted_column:
        arrow_direction = ''
        last_sort_index = sorted_column[column]
        if last_sort_index.startswith('-'):
            arrow_direction = 'bottom'
        else:
            arrow_direction = 'top'
        ele = '<span class ="glyphicon glyphicon-triangle-%s" aria-hidden="true" > </span>'%arrow_direction
        return mark_safe(ele)
    return ""
    ...
```

table_obj_list.html

```html
<tr>
    {% if admin_class.list_display %}
        {% for column in admin_class.list_display %}
            <th><a href="?_o={% get_sorted_column column sorted_column forloop.counter0  %}">
            {{ column }}
            {% render_sorted_arrow column sorted_column %}
            </a></th>

        {% endfor %}
    {% else %}
        {#<th>{{ admin_class.model._meta.model_name }}</th> 不能以_开头#}
        <th>{% get_model_name admin_class %}</th>
    {% endif %}
</tr>
```

##### 3）排序、筛选、分页组合

 其功能实现主要是获取三者的url，对url进行拼接。

排序、筛选组合

table_obj_list.html

```html
<tr>
    {% if admin_class.list_display %}
    {% for column in admin_class.list_display %}
    <th><a href="?_o={% get_sorted_column column sorted_column forloop.counter0 %}{% render_filtered_args admin_class %}">
        {{ column }}
        {% render_sorted_arrow column sorted_column %}
        </a></th>

    {% endfor %}
    {% else %}
    {#<th>{{ admin_class.model._meta.model_name }}</th> 不能以_开头#}
    <th>{% get_model_name admin_class %}</th>
    {% endif %}
</tr>
```

useradmin_tags.py

```python
@register.simple_tag
def render_filtered_args(admin_class):
    """拼接筛选的字段"""
    if admin_class.filter_conditions:
        ele = ''
        for k,v in admin_class.filter_conditions.items():
            ele += '&%s=%s'%(k,v)
        return mark_safe(ele)
    else:
        return ''
```

筛选、分页

table_ob_list.html

```html
    <div class="pagination">


        {% render_paginator querysets admin_class %}
```

useradmin_tags.py

```python
...
@register.simple_tag
def render_filtered_args(admin_class,render_html=True):
    """拼接筛选的字段"""
    if admin_class.filter_conditions:
        ele = ''
        for k,v in admin_class.filter_conditions.items():
            ele += '&%s=%s'%(k,v)
        if render_html:
            return mark_safe(ele)
        else:
            return ele
    else:
        return ''
...
@register.simple_tag
def render_paginator(querysets,admin_class):
    ele = """
        <ul class="pagination">
    """
    pre_disabled = 'class = "disabled"'
    next_disabled = 'class = "disabled"'
    filter_ele = ''
    ele_p = ''
    pre_href = ''
    next_href = ''


    for i in querysets.paginator.page_range:
        if abs(querysets.number - i) < 2:  # 要显示的页码范围
            active = ''
            if querysets.number == i:  # current page
                active = 'active'
            filter_ele = render_filtered_args(admin_class)
            p_ele = """<li class="%s"><a href="?_page=%s%s">%s</a></li>""" % (active, i,filter_ele, i)
            ele_p += p_ele
    if querysets.number > 1:
        previous = querysets.number - 1
        pre_disabled = ''
        pre_href = "href='?_page=%s%s'" % (previous,filter_ele)
    ele += '<li %s><a %s aria-label="Previous"><span aria-hidden="true">&laquo;</span></a></li>' % (
        pre_disabled, pre_href)
    ele += ele_p
    if querysets.has_next():
        # print(querysets.has_next)
        next = querysets.number + 1
        next_disabled = ''
        next_href = "href='?_page=%s%s'" %(next,filter_ele)
    # print(next_href)
    ele += '<li %s><a %s aria-label="Previous"><span aria-hidden="true">&raquo;</span></a></li>' % (
        next_disabled, next_href)

    ele += "</ul>"

    return mark_safe(ele)
```

测试发现：筛选排序还有一部分没有完成

页面上设置一个隐藏的input 内容是正在排序的字段

table_obj_list.html

```html
		<form action="">
                {% for filter_column in admin_class.list_filter %}
                    {% build_filter_ele filter_column admin_class %}
                {% endfor %}
                <input type="hidden" name="_o" value="{% get_current_sorted_colum_index sorted_column %}">
                <input type="submit" value="确定">
            </form>
```

useradmin_tags.py

```python
@register.simple_tag
def get_current_sorted_colum_index(sorted_column):

    return list(sorted_column.values())[0] if sorted_column else ''
```

加上分页功能

table_obj_list.html

```html
...    
<div class="pagination">


        {% render_paginator querysets admin_class sorted_column %}


        {#        <span class="step-links">#}
        {#            {% if querysets.has_previous %}#}
        {#                <a href="?_page={{ querysets.previons_page_number }}">previous</a>#}
        {#            {% endif %}#}
        {#            <span class="current">#}
        {#            Page    {{ querysets.number }} of {{ querysets.paginator.num_pages }}#}
        {#            </span>#}
        {#            {% if querysets.has_next %}#}
        {#                <a href="?_page={{ querysets.next_page_number }}">next</a>#}
        {#            {% endif %}#}
        {##}
        {#        </span>#}
        {#    </div>#}

</div>
...
```

useradmin_tags.py

```python
...
@register.simple_tag
def render_paginator(querysets,admin_class,sorted_column):
    ele = """
        <ul class="pagination">
    """
    pre_disabled = 'class = "disabled"'
    next_disabled = 'class = "disabled"'
    filter_ele = ''
    ele_p = ''
    pre_href = ''
    next_href = ''
    sorted_ele = ''

    for i in querysets.paginator.page_range:
        if abs(querysets.number - i) < 2:  # 要显示的页码范围
            active = ''
            if querysets.number == i:  # current page
                active = 'active'
            filter_ele = render_filtered_args(admin_class)

            if sorted_column:
                sorted_ele = '&_o=%s'%list(sorted_column.values())[0]

            p_ele = """<li class="%s"><a href="?_page=%s%s%s">%s</a></li>""" % (active, i,filter_ele,sorted_ele, i)
            ele_p += p_ele
    if querysets.number > 1:
        previous = querysets.number - 1
        pre_disabled = ''
        pre_href = "href='?_page=%s%s%s'" % (previous,filter_ele,sorted_ele)
        ele += '<li %s><a %s aria-label="Previous"><span aria-hidden="true">&laquo;</span></a></li>' % (
        pre_disabled, pre_href)
    ele += ele_p
    if querysets.has_next():
        # print(querysets.has_next)
        next = querysets.number + 1
        next_disabled = ''
        next_href = "href='?_page=%s%s%s'" %(next,filter_ele,sorted_ele)
    # print(next_href)
        ele += '<li %s><a %s aria-label="Previous"><span aria-hidden="true">&raquo;</span></a></li>' % (
        next_disabled, next_href)

    ele += "</ul>"

    return mark_safe(ele)
...
```

这样就实现了排序、筛选、分页的组合

### 5、搜索

使用Q查询

from  django.db.models  import  Q

##### 1）首先做一个搜索框

admin页面确定了是筛选后的搜索结果

table_obj_list.html

```html
...
<h2 class="page-header">App</h2>
    <div>
        {#    {{ querysets }}#}

        <form>
            <input type="search" name="_q">
            <input type="submit" value="Search">
        </form>
...
```

views.py 过滤条件上加上搜索的name属性，以防止搜索时出错

```python
...
from django.db.models import Q
...
def get_filter_result(request, querysets):
    filter_conditions = {}
    for key, value in request.GET.items():
        if key in ('_page', '_o','_q'):
            continue
        if value:
            filter_conditions[key] = value
...
```

创建一个搜索方法，并调用

views.py

```python
...
def get_orderby_result(request, querysets, admin_class):
    """排序"""

    current_ordered_column = {}
    orderby_index = request.GET.get('_o')
    # print(orderby_index)
    if orderby_index:  # 有排序
        # orderby_index = orderby_index.strip()
        orderby_key = admin_class.list_display[abs(int(orderby_index))]

        # 为了让前端知道当前的排序的列
        current_ordered_column[orderby_key] = orderby_index

        if orderby_index.startswith('-'):
            orderby_key = '-' + orderby_key
        # print("==========")
        # print(orderby_key)
        # print(querysets.order_by(orderby_key))
        # print(current_ordered_column)
        return querysets.order_by(orderby_key), current_ordered_column
    else:
        # print('---------')
        return querysets, current_ordered_column
...
def table_obj_list(request, app_name, model_name):
    ...
    querysets, filter_conditions = get_filter_result(request, querysets)
    admin_class.filter_conditions = filter_conditions

    # search queryset result
    querysets = get_search_result(request, querysets, admin_class)

    # sorted_querysets
    # print(querysets)
    querysets, sorted_column = get_orderby_result(request, querysets, admin_class)
...
```

此时仅搜索功能好了

##### 2）url拼接

前端添加隐藏域用于获取筛选条件

table_obj_list.html

```html
        ...
        <form>
            <input type="search" name="_q">
            <input type="submit" value="Search">

            {% for k,v in admin_class.filter_conditions.items %}
                <input type="hidden" name="{{ k }}" value="{{ v }}">
            {% endfor %}

        </form>
        ...
```

这样就实现了

##### 3）显示当前搜索项

views.py

```python
...
querysets = get_search_result(request, querysets, admin_class)
admin_class.search_key = request.GET.get('_q','')
...
```

table_obj_list.html

```html
        <form>
            <input type="search" name="_q" value="{{ admin_class.search_key }}">
            <input type="submit" value="Search">

            {% for k,v in admin_class.filter_conditions.items %}
                <input type="hidden" name="{{ k }}" value="{{ v }}">
            {% endfor %}

        </form>
```

##### 4）搜索组合分页

useradmin_tags.py

```python
...
@register.simple_tag
def render_filtered_args(admin_class,render_html=True,search_key=True):
    """拼接筛选的字段"""

    if admin_class.filter_conditions:
        ele = ''
        for k,v in admin_class.filter_conditions.items():
            ele += '&%s=%s'%(k,v)
        if render_html:
            return mark_safe(ele)
        else:
            return ele
    elif admin_class.search_key:
        ele = '&_q=%s' % admin_class.search_key
        if search_key:
            # print(admin_class.search_key)
            return ele
    else:
        return ''
...
```

##### 5）为页面添加css样式

![04_04 前端效果图06](.\img\04_04 前端效果图06.png)

