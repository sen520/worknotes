##### 变量

python 的变量为万能的变量，它是弱类型的语言，变量的类型随值类型而定。值的基本类型有:
		Number（数字）：int、float、bool、complex（复数）
		String（字符串）
		List（列表）
		Tuple（元组）
		Sets（集合）
		Dictionary（字典）

​	不可变对象：int、string、float、tuple	(数字、字符、元组)

进制转换

```
num = 5      #十进制表示    int(5)
num = 0b101  #二进制表示    bin(5)
num = 0o5    #八进制表示    oct(5)
num = 0x5    #十六进制表示  hex(5)

转换成十进制 int('100',2)
```

##### 类型转换

```
函数 						说明
int(x [,base]) 			将 x 转换为一个整数
float(x)			    将 x 转换到一个浮点数
complex(real [,imag]) 	 创建一个复数
str(x) 					将对象 x 转换为字符串
repr(x) 				将对象 x 转换为表达式字符串
eval(str) 				用来计算在字符串中的有效 Python
						表达式,并返回一个对象
tuple(s) 				将序列 s 转换为一个元组
list(s) 				将序列 s 转换为一个列表
set(s) 					转换为可变集合
dict(d) 				创建一个字典。d 必须是一个序列
(key,value)				元组
frozenset(s) 			转换为不可变集合
chr(x) 					将一个整数转换为一个字符
ord(x) 					将一个字符转换为它的整数值
hex(x) 					将一个整数转换为一个十六进制字符串
oct(x) 					将一个整数转换为一个八进制字符串
“” ’’ 					false
```



##### 循环控制

###### 1、四要素

​	初始表达式：循环起始变量；

​	条件表达式：用于判断循环结构的条件；

​	循环体：重复执行的代码块；

​	迭代因子：改变循环条件的变量，使循环趋向于结束的语句

###### 2、while

```
初始语句
while 布尔表达式 :
	循环体
	迭代因子
else :
	条件不满足执行
	
# 语句中应有使循环趋向于结束的语句，否则会出现无限循环–––" 死"循环
```

###### 3、break & continue

循环结束(break)与暂停(continue)。
	循环结束分为两种情况: 正常执行完毕即条件不成立或者遇到break；而暂停则continue是暂停本次，继续下一次。

###### 4、死循环：条件永远为 true

死循环

死循环是指条件永远为true,注意死循环不一定是错误的，

如服务器就是一个大大的死循环，不间断服务着。

```
a = 10
b = 1
while a > b:
	print("24 小时为你服务。。。")
```

###### 5、for 循环

结构: for x in 常用有长度的类型中

```
# 统计 1...到 10 的数
sum = 0
for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
	sum = sum + x
print(sum)
# 统计 1...到 10 的数
sum = 0
for x in range(11):
	sum = sum + x
print(sum)
# 遍历列表
names = [shsxt, 'sxt', 'bjsxt']
for n in names:
	print(n)
```

###### 6、pass

pass 其实是空语句 do nothing，占位符

##### 列表

列表是一种无序的可重复的多种类型数据的序列，可以动态的添加和删除其中的元素。列表的容量可在程序运行时动态变化，长度也随之变化。列表的每一个元素都有一个索引，索引从 0 开始，使用[]创建，并使用,作为元素的分割。列表中元素的类型可以不相同，支持数字，字符串甚至可以包含列表（就是可以嵌套）

使用 list()构造函数构建，传入的对象必须为可遍历的对象 iterable

```
In [1]: a = list([1,2,3,4])

In [2]: print(a)
[1, 2, 3, 4]

In [3]: a = list(range(0,10))

In [4]: a
Out[4]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

###### 	切片

​	[1,5) 的元素: 注意不包含 5 的元素  [1:5]
		所有的元素 [0:] 或[:]
		偶数索引的元素 [0::2]
		前2 个元素 [:2]
		最后一个元素 [-1]
		倒数第二个元素 [-2]
		倒序访问最后四个元素 [-1:-5:-1]
		访问倒数第二个到第四个 [-2:4]

###### 抽取赋值

以某一步长对列表进行抽取，重新赋值后形成新的列表。
	list[ i : j : k] = [1, 2,3] 即以 k 为步长，对下标为 i 与j（左闭右开）之间的元素按 k 步长进行抽取后进行赋值，注意必须个数匹配

```
In [11]: a = [0,1,2,3,4,5,6,7,8,9]

In [12]: a[0:9:3] = [12,23,34]

In [13]: a
Out[13]: [12, 1, 2, 23, 4, 5, 34, 7, 8, 9]
```

###### 常见方法

| 操作                  | 作用                                                         |
| --------------------- | ------------------------------------------------------------ |
| append(item)          | 列表末尾插入 item                                            |
| insert(index,item)    | 在位置 index 插入 item                                       |
| extend(newlist)       | 将 newlist 列表中的元素添加到列表末尾                        |
| remove(element)       | 删除首次在列表中出现的 element                               |
| del s[i:j:k]          | 等同于 s[i:j:k] = [] 删除 i 到 j 以步长为                    |
| pop([index])          | index 位置参数是可选的。如果无参数，则会删除并返回最后一个元素；有参数则删除并返回指定位置的元素。 |
| clear()               | 清空列表                                                     |
| len(列表)             | 获取列表长度                                                 |
| count(element)        | 返回 element 在列表中的个数                                  |
| index(element)        | 返回 element 在列表中的首次出现的索引。                      |
| reverse()             | 反转列表中的内容                                             |
| list.\__contains__(a) | 判断list中是否含有a元素                                      |
| copy()                | 复制出一个新的列表                                           |
| sort(reverse=False)   | 排序：False 就是按从小到大，True 就是从大到小， 默认是 False |

```
In [26]: a = [1,2,3,4,5,6,7,8,9,0]

In [27]: a
Out[27]: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]

In [28]: del a[0:9:2]

In [29]: a
Out[29]: [2, 4, 6, 8, 0]

In [30]: a.reverse()

In [31]: a
Out[31]: [0, 8, 6, 4, 2]

# 判断元素是否存在
In [32]: a.__contains__(0)
Out[32]: True

In [33]: a.__contains__(3)
Out[33]: False

# 连接
In [37]: a + b
Out[37]: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 同时访问下标和元素
In [38]: for index,item in enumerate(a):
    ...:     print(index,item)
    ...:
0 1
1 2
2 3
3 4
4 5

# 删除下标为0的元素
In [39]: a.__delitem__(0)

In [40]: a
Out[40]: [2, 3, 4, 5]

# 判断元素是否在列表中
In [41]: 2 in a
Out[41]: True

In [42]: 1 in a
Out[42]: False

In [43]: 1 not in a
Out[43]: True

In [51]: a
Out[51]: [2, 3, 4, 5, 1, 2, 3, 7]

# copy出一个新的列表
In [53]: b = a.copy()

In [54]: b
Out[54]: [2, 3, 4, 5, 1, 2, 3, 7]

In [55]: a
Out[55]: [2, 3, 4, 5, 1, 2, 3, 7]

# 修改b的值，a不会变
In [56]: b[0] = 1

In [57]: a
Out[57]: [2, 3, 4, 5, 1, 2, 3, 7]

In [58]: b
Out[58]: [1, 3, 4, 5, 1, 2, 3, 7]

# 直接把a赋值给c，数据改变，两个全变
In [59]: c = a

In [60]: c
Out[60]: [2, 3, 4, 5, 1, 2, 3, 7]

In [61]: a
Out[61]: [2, 3, 4, 5, 1, 2, 3, 7]

In [62]: c[0] = 1

In [63]: c
Out[63]: [1, 3, 4, 5, 1, 2, 3, 7]

In [64]: a
Out[64]: [1, 3, 4, 5, 1, 2, 3, 7]

# 去重
In [65]: b = []

In [66]: for i in a:
    ...:     if i not in b:
    ...:         b.append(i)
    ...:

In [67]: print(b)
[1, 3, 4, 5, 2, 7]

```

##### 字典

元素为键值对，键必须是唯一的且不可变，如键已存在值就覆盖。

查找和插入的速度极快，不会随着 key 的增加而增加；
	需要占用大量的内存，内存浪费多。dict 是用空间来换取时间的一种方法。

###### hash

dict 可以用在需要快速查找的很多地方，在以后的代码中几乎无处不在，需要注意的是 key 必须是不可变对象。在操作 dict 时，内部需要根据 key 来计算 value 的存储位置，如果每次计算相同的 key 得出的结果不同，那 dict 内部就完全混乱了。这个通过 key 计算位置的算法称为哈希算法（Hash）。
	要保证 hash 的正确性，作为 key 的对象就不能变。在Python 中，字符串、整数等都是不可变的，因此，可以放心地作为 key。而 list 是可变的，就不能作为 key。

###### 常用方法

| 作用                     | 操作                                                         |
| ------------------------ | ------------------------------------------------------------ |
| [ 键 ]= 值               | 添加键值对，如果存在覆盖                                     |
| \__setitem__             | 存在则覆盖，不存在新建                                       |
| pop(key)                 | 指定 key 删除对应的 value，没有会报错                        |
| pop(key,x)               | 避免错误，返回x                                              |
| popitem()                | 删除任意键-值对，并作为两个元素的一个元组返回。如果字典为空，会产生 KeyError 异常 |
| clear()                  | 从字典中删除所有项                                           |
| update(newdic)           | 将来自 newdic 的所有键-值对添加到当前字典中，并覆盖同名键的值 |
| get(key[ ，returnValue]) | 返回 key 对应的值；如果 key 不在字典中，同时指定了 returnValue，就返回指定的值。如果没有指定 returnValue，就返回 none。 |
| items()                  | 返回一个由元组构成的列表，每个元组包含一个键-值对            |
| keys()                   | 返回字典中所有键的列表                                       |
| values()                 | 返回字典所有值的一个列表                                     |
| fromkeys(seq[,value]))   | 将 seq 中的元素作为 key，返回一个字段。对应的value 为可选的，默认为 None。用于对多个 key进行初始化。 |
| has_key(key)             | 如果 key 在字典中，就返回 1，否则返回 0                      |
| copy()                   | 创建并返回字典的一个浅拷贝（新字典中的元素是对原始字典中元素的引用） |

```

In [69]: dic = {'name':'老王', 'sex':1, 'address':'隔壁',
    ...: 'address':'松江'}

# 添加key-value
In [70]: dic['no'] = 1

In [71]: dic
Out[71]: {'name': '老王', 'sex': 1, 'address': '松江', 'no': 1}

# 添加
In [72]: dic = {}.fromkeys(['a','b','c'],[1,2,3])

In [73]: dic
Out[73]: {'a': [1, 2, 3], 'b': [1, 2, 3], 'c': [1, 2, 3]}

In [74]: d = {}.fromkeys(['a','b','c'],None)

In [75]: d
Out[75]: {'a': None, 'b': None, 'c': None}


In [78]: a = {'name':'老王', 'sex':1, 'address':'隔壁',
    ...: 'address':'松江'}

In [79]: a['no'] = 1

# 删除
In [80]: a
Out[80]: {'name': '老王', 'sex': 1, 'address': '松江', 'no': 1}

In [81]: del a['no']  # 如果没有键 no 会出现异常

In [82]: a
Out[82]: {'name': '老王', 'sex': 1, 'address': '松江'}

In [83]: a.pop('sex')  # 成功返回 1 如果没有 key，默认错误
Out[83]: 1

In [84]: a
Out[84]: {'name': '老王', 'address': '松江'}

In [85]: a.pop('sex',-1)  # 避免错误，返回-1
Out[85]: 1

In [86]: a = {'name':'老王', 'sex':1, 'address':'隔壁',
    ...: 'address':'松江'}

# 存在则覆盖，不存在新建
In [87]: a.__setitem__('name','aa')

In [88]: a
Out[88]: {'name': 'aa', 'sex': 1, 'address': '松江'}

In [89]: a.__setitem__('x','aa')

In [90]: a
Out[90]: {'name': 'aa', 'sex': 1, 'address': '松江', 'x': 'aa'}
```

###### 	集合

​	集合（set）和 dict 类似，只是**一组 key 的集合**，但不存储 value。可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }。

- 可以把一个 list 变成 set 
- 无序，元素不重复，可以修改（数学里面集合的性质）要求可以计算hash 元素本身不可变
- ==add() 只能添加不可改变的值==

```
集合的创建 需要一个列表

In [17]: a=set([1,2,3,4]) #创建
    ...: a.add('test') #添加
    ...: a.remove('test') #删除元素
    ...:
    ...: for x in a:
    ...:     print(x)
    ...:
1
2
3
4
```

###### 	双向队列 

```
In [18]: from collections import deque
    ...:
    ...: a=deque([1,2])
    ...: a.append('3')
    ...: a.appendleft(0)
    ...: print(a) # [0,1,2,3]
    ...:
    ...:
deque([0, 1, 2, '3'])
```

###### 	名称列表 

```
In [20]: from collections import namedtuple,deque
    ...: P=namedtuple('P',('name','city'))  # 尽量把变量名取得和里面的参数一致
    ...: one=P('zs','x')
    ...: print(one.name,one.city)
    ...:
    ...:
zs x
```

###### 	有序字典

```
In [21]: from collections import OrderedDict
    ...: d=OrderedDict({'name':'zs','city':'x'})
    ...: for k,v in d.items():
    ...:     print(k,v)
    ...:
name zs
city x

In [22]:
```

###### 	枚举类型

enumerate 

```

In [23]: l=['a','b','c','d']
    ...: for index,value in enumerate(l):
    ...:     print(index,value)
    ...:
0 a
1 b
2 c
3 d
```

##### 元组

tuple 和 list 非常类似，但是 tuple 一旦初始化就不能修改。元组采用圆括号表示。 tuple 被定义下来后就不可被改变了，没有 append()，insert()这样修改的方法。其他获取元素的方法和list是一样的，可以正常地使用tuple[0]、tuple[-1]进行访问，但不能赋值成另外的元素。程序通常不遍历元组，而是只访问完成当前任务所需的元组的一部分。
因为 tuple 不可变即只读，所以代码更安全。如果可能，能用 tuple 代替 list 就尽量用 tuple，提高性能且安全。

###### 	1 、特点

元素有序，可重复，元素内容不可变，元素多样性。

###### 	2、构建

定义一个元素的元组时，一定要在末尾加上逗号，不加逗号，解释器会认为这个括号只是一个数学符号。

```
In [5]: tup = (1,)

In [6]: type(tup)
Out[6]: tuple
```

#### 元组、列表、集合对比

| 类型          | 长度可变 | 元素多样 | 元素可操作 | 元素可重复 |
| ------------- | -------- | -------- | ---------- | ---------- |
| 元组（tuple） | 否       | 是       | 否         | 是         |
| 列表（list）  | 是       | 是       | 是         | 是         |
| 集合（set）   | 是       | 是       | 是         | 否         |

####  enumerate

enumerate函数用于遍历**序列中的元素以及它们的下标**,多用于在for 循环中得到计数,enumerate 参数为可遍历的变量，如 字符串，列表等。
