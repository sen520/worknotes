#### Tornado ####

Tornado是一个==Python Web框架和异步网络库==，最初是在FriendFeed开发的。通过使用非阻塞网络I /O，Tornado可以扩展到数以万计的开放连接，非常适合 长时间轮询， WebSockets和其他需要与每个用户建立长期连接的应用程序。

Tornado 和现在的主流 Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其 非阻塞的方式和对 epoll的运用，Tornado 每秒可以处理数以千计的连接，因此 Tornado 是实时 Web 服务的一个 理想框架。我们开发这个 Web 服务器的主要目的就是为了处理 FriendFeed 的实时功能 ——在 FriendFeed 的应用里每一个活动用户都会保持着一个服务器连接。



#### Tornado和Django的区别 ####
###### Django ######
- 注重高效开发
- 全自动化的管理后台（只需要使用起ORM，做简单的定义，就能自动生成数据库结构，全功能的管理后台）
- session功能


##### Tornado #####
- 注重性能优越，速度快
- 解决高并发
- 异步非阻塞
- websockets 长连接
- 内嵌了HTTP服务器
- 单线程的异步网络程序，默认启动时根据CPU数量运行多个实例；利用CPU多核的优势。



#### Epoll ####
 
 IO多路复用除了select，还有两种方式，poll 和 epoll

在windows下只支持select,而在linux中，这三个都有。epoll是性能最好的，select唯一的优点是多平台都可以用，但是缺点也很明显，就是效率很差。poll是epoll和select的中间过渡，与select相比，poll可以监听的数量没有限制。epoll没有最大连接上限，另外监听机制也完全发生变化，select的机制是轮询（每个数据都检查一遍，即使找到有变化的也会继续检查），epoll的机制是用回调函数，哪个对象有变化，那个就调用这个回调函数

在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。

epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先的select/poll调用分成了3个部分：

1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)

2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字

3）调用epoll_wait收集发生的事件的连接

如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。

Epoll模型参考网址：http://blog.csdn.net/shenya1314/article/details/73691088